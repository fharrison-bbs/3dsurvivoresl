<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ESL Powerup Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            position: fixed;
            overflow: hidden;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
        }
        
        #gameContainer {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        /* ===== TOUCH CONTROLS ===== */
        #touchControls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            z-index: 10;
        }
        
        .joystick {
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid rgba(0, 255, 0, 0.3);
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .joystick-thumb {
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            position: absolute;
            border: 2px solid #0f0;
        }
        
        #shootButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            background: rgba(255, 0, 0, 0.2);
            border: 3px solid #f00;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            z-index: 10;
            color: #f00;
        }
        
        #lookPad {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            background: rgba(100, 100, 255, 0.1);
            border: 2px solid rgba(100, 100, 255, 0.3);
            border-radius: 8px;
            z-index: 10;
        }
        
        /* ===== UI PANELS ===== */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            min-width: 200px;
            z-index: 5;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            text-align: right;
            z-index: 5;
        }
        
        .stat-line {
            margin: 6px 0;
            display: flex;
            justify-content: space-between;
            gap: 15px;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            color: #0f0;
            font-weight: bold;
        }
        
        .health-bar {
            width: 180px;
            height: 18px;
            background: #333;
            border: 2px solid #666;
            margin-top: 8px;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #0a0);
            transition: width 0.2s;
        }
        
        /* ===== QUESTION MODAL ===== */
        #questionModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 100;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 20px;
        }
        
        #questionModal.active {
            display: flex;
        }
        
        #questionContainer {
            background: rgba(20, 40, 80, 0.9);
            border: 3px solid #0f0;
            border-radius: 12px;
            padding: 30px;
            max-width: 90vw;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
        }
        
        #questionText {
            font-size: 18px;
            margin-bottom: 25px;
            line-height: 1.4;
            color: #0f0;
        }
        
        .option-button {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: rgba(0, 100, 100, 0.5);
            border: 2px solid #0f0;
            color: #0f0;
            border-radius: 8px;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            touch-action: manipulation;
        }
        
        .option-button:active {
            background: rgba(0, 255, 0, 0.3);
            transform: scale(0.98);
        }
        
        .option-button.correct {
            background: rgba(0, 200, 0, 0.7);
            color: #fff;
        }
        
        .option-button.incorrect {
            background: rgba(255, 0, 0, 0.7);
            color: #fff;
        }
        
        #feedback {
            margin-top: 20px;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            min-height: 30px;
        }
        
        #feedback.correct {
            color: #0f0;
        }
        
        #feedback.incorrect {
            color: #f00;
        }
        
        /* ===== POWERUP DISPLAY ===== */
        #activePowerups {
            position: absolute;
            bottom: 120px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px;
            border-radius: 8px;
            max-width: 220px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 11px;
            z-index: 5;
        }
        
        .powerup-item {
            padding: 4px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.1);
            border-left: 3px solid #0f0;
            border-radius: 3px;
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid #0f0;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
        }
        
        .crosshair::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 10px;
            background: #0f0;
            left: 50%;
            transform: translateX(-50%);
            top: -15px;
        }
        
        .crosshair::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 10px;
            background: #0f0;
            left: 50%;
            transform: translateX(-50%);
            bottom: -15px;
        }
        
        #gameMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #0f0;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            font-size: 18px;
            z-index: 50;
            display: none;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="crosshair"></div>
        
        <div id="ui">
            <div class="stat-line">
                <span class="stat-label">Health:</span>
                <span class="stat-value" id="health">100</span>
            </div>
            <div class="health-bar">
                <div class="health-bar-fill" id="healthBar" style="width: 100%"></div>
            </div>
            <div class="stat-line">
                <span class="stat-label">Ammo:</span>
                <span class="stat-value" id="ammo">10</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">Score:</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">Streak:</span>
                <span class="stat-value" id="streak">0</span>
            </div>
        </div>
        
        <div id="stats">
            <div class="stat-line">
                <span class="stat-label">Enemies:</span>
                <span class="stat-value" id="enemyCount">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">Powerups:</span>
                <span class="stat-value" id="powerupCount">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">Correct:</span>
                <span class="stat-value" id="correct">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">Wrong:</span>
                <span class="stat-value" id="wrong">0</span>
            </div>
        </div>
        
        <div id="activePowerups">
            <div style="font-weight: bold; margin-bottom: 6px; color: #0f0;">Active:</div>
            <div id="powerupsList"></div>
        </div>
        
        <!-- TOUCH CONTROLS -->
        <div id="touchControls">
            <div class="joystick">
                <div class="joystick-thumb"></div>
            </div>
        </div>
        
        <div id="lookPad"></div>
        <div id="shootButton">SHOOT</div>
        
        <!-- QUESTION MODAL -->
        <div id="questionModal">
            <div id="questionContainer">
                <div id="questionText"></div>
                <div id="optionsContainer"></div>
                <div id="feedback"></div>
            </div>
        </div>
        
        <div id="gameMessage"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ===== ESL QUESTION POOL (50 Questions) =====
        const QUESTION_POOL = [
            // Fables & Stories
            { q: "Complete: 'A _____ usually has a moral or a life lesson.'", a: ["fable", "dialogue", "simile", "civilization"], c: 0 },
            { q: "What is the main purpose of a fable?", a: ["to teach a lesson", "to entertain", "to describe events", "to tell jokes"], c: 0 },
            { q: "Which word best completes: 'The _____ was very confusing with many characters talking at once.'", a: ["dialogue", "fable", "narrative", "moral"], c: 0 },
            { q: "A _____ is a story passed down through generations.", a: ["legend", "fable", "poem", "essay"], c: 0 },
            { q: "Which sentence uses 'but' as a transitional word correctly?", a: ["He studied hard but failed the test.", "But he studied hard failed the test.", "He but studied hard failed test.", "Studied hard but he failed test."], c: 0 },
            { q: "What does 'moral of the story' mean?", a: ["the lesson learned", "the ending", "the main character", "the setting"], c: 0 },
            { q: "Complete: 'Once upon a time, there was a _____ who lived in the forest.'", a: ["character", "dialogue", "theme", "sequence"], c: 0 },
            { q: "Which is an example of a transitional word used to show sequence?", a: ["next", "but", "however", "still"], c: 0 },
            
            // King Tutankhamun & Ancient Egypt
            { q: "When was King Tutankhamun's tomb discovered?", a: ["Nov 1922", "Nov 1920", "Nov 1925", "Nov 1919"], c: 0 },
            { q: "How old was Tutankhamun when he became Pharaoh?", a: ["9 years old", "7 years old", "12 years old", "15 years old"], c: 0 },
            { q: "Remains wrapped in cloth and kept in a case are called a _____.", a: ["mummy", "sarcophagus", "hieroglyphic", "tomb"], c: 0 },
            { q: "Who discovered King Tutankhamun's tomb?", a: ["Howard Carter", "Napoleon Bonaparte", "Cleopatra", "Ramesses II"], c: 0 },
            { q: "In which country is the Valley of the Kings located?", a: ["Egypt", "Greece", "Peru", "Mexico"], c: 0 },
            { q: "What is a _____ - a stone coffin used by ancient Egyptians?", a: ["sarcophagus", "pyramid", "sphinx", "cartouche"], c: 0 },
            { q: "How old was Tutankhamun when he died?", a: ["18 years old", "25 years old", "30 years old", "35 years old"], c: 0 },
            { q: "What ancient Egyptian writing system used pictures and symbols?", a: ["hieroglyphics", "alphabet", "numerals", "cuneiform"], c: 0 },
            { q: "The treasures found in Tutankhamun's tomb are now displayed in a _____.", a: ["museum", "pyramid", "palace", "temple"], c: 0 },
            { q: "Why was Tutankhamun's tomb important to archaeologists?", a: ["it was well-preserved", "it was the largest", "it was the oldest", "it was decorated"], c: 0 },
            { q: "What year did Howard Carter begin his search for the tomb?", a: ["1922", "1915", "1920", "1925"], c: 0 },
            
            // Aboriginal Art & Culture
            { q: "What material did Aboriginal artists use for black color?", a: ["charcoal", "clay", "ochre", "bark"], c: 0 },
            { q: "In Aboriginal dot painting, what does the yellow dot represent?", a: ["the sun", "desert sand", "the soil", "the clouds"], c: 0 },
            { q: "What does Aboriginal dot painting traditionally depict?", a: ["stories and journeys", "people and animals", "plants and flowers", "weather patterns"], c: 0 },
            { q: "Which color in Aboriginal art traditionally represents water or rain?", a: ["blue", "red", "yellow", "white"], c: 0 },
            { q: "Complete: 'Aboriginal artists often used _____ from the earth to make paints.'", a: ["natural pigments", "modern dyes", "synthetic colors", "imported materials"], c: 0 },
            { q: "What is a traditional Aboriginal dot painting called?", a: ["songline art", "rock art", "bark art", "body art"], c: 0 },
            { q: "How long has Aboriginal art existed in Australia?", a: ["over 60,000 years", "about 5,000 years", "about 2,000 years", "about 500 years"], c: 0 },
            { q: "What do Aboriginal songlines represent?", a: ["paths connecting sacred sites", "musical instruments", "dance movements", "story themes"], c: 0 },
            { q: "Aboriginal artists traditionally painted on _____.", a: ["rock, bark, and sand", "canvas and wood", "metal and clay", "stone tablets"], c: 0 },
            { q: "In Aboriginal culture, art is often connected to _____.", a: ["spirituality and land", "commerce and trade", "entertainment only", "military purposes"], c: 0 },
            
            // Water & Geography
            { q: "The water flowed from one side of town to the other in a very long _____.", a: ["stream", "river", "passage", "channel"], c: 0 },
            { q: "Which word means a small river?", a: ["stream", "lake", "ocean", "pond"], c: 0 },
            { q: "Complete: 'The _____ carried water to distant villages.'", a: ["channel", "bridge", "road", "path"], c: 0 },
            { q: "Water that flows naturally is called a _____.", a: ["current", "wave", "tide", "flow"], c: 0 },
            
            // Numbers & Roman Numerals
            { q: "_____ are used in a counting system around for hundreds of years.", a: ["Roman numerals", "binary codes", "decimals", "algorithms"], c: 0 },
            { q: "What does the Roman numeral 'X' represent?", a: ["10", "5", "50", "100"], c: 0 },
            { q: "How do you write 50 in Roman numerals?", a: ["L", "C", "D", "M"], c: 0 },
            { q: "Complete: 'IX in Roman numerals equals _____.'", a: ["9", "11", "14", "6"], c: 0 },
            
            // Grammar & Literary Devices
            { q: "Words like 'but, so, and, next' are _____.", a: ["transitional words", "adjectives", "similes", "verbs"], c: 0 },
            { q: "Comparisons using 'like' or 'as' are called _____.", a: ["similes", "metaphors", "dialogues", "sequences"], c: 0 },
            { q: "Which is NOT a transitional word?", a: ["beautiful", "however", "therefore", "meanwhile"], c: 0 },
            { q: "Complete: 'She ran _____ the wind.'", a: ["like", "as", "similar to", "same as"], c: 0 },
            { q: "A metaphor is a comparison without using 'like' or 'as'. Which is an example?", a: ["The world is a stage.", "The world is like a stage.", "The world seems like a stage.", "The world appears as a stage."], c: 0 },
            { q: "Which transitional word shows contrast?", a: ["however", "then", "next", "also"], c: 0 },
            { q: "Complete: 'He worked hard; _____, he succeeded.'", a: ["therefore", "also", "next", "still"], c: 0 },
            { q: "What is a _____ - direct conversation between characters?", a: ["dialogue", "monologue", "narrative", "description"], c: 0 },
            { q: "Which word best continues: 'First, we prepared. _____, we cooked.'", a: ["Next", "But", "However", "Still"], c: 0 },
            { q: "A simile compares two things using:", a: ["'like' or 'as'", "'is' or 'was'", "'and' or 'or'", "'if' or 'then'"], c: 0 },
            { q: "Complete: 'The _____ between the two friends was very interesting to watch.'", a: ["dialogue", "debate", "argument", "discussion"], c: 0 },
            { q: "Which sentence contains a transitional phrase?", a: ["On the other hand, she disagreed.", "She disagreed loudly.", "She really disagreed.", "She disagreed very much."], c: 0 }
        ];

        // ===== GAME STATE =====
        const gameState = {
            health: 100,
            maxHealth: 100,
            ammo: 10,
            maxAmmo: 10,
            score: 0,
            streak: 0,
            correct: 0,
            wrong: 0,
            activePowerups: [],
            questionActive: false,
            currentQuestion: null
        };

        // ===== THREE.JS SETUP =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 100, 500);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.getElementById('gameContainer').appendChild(renderer.domElement);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.left = '0';
        renderer.domElement.style.zIndex = '1';

        // ===== LIGHTING =====
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // ===== ARENA =====
        const groundGeom = new THREE.PlaneGeometry(200, 200);
        const groundMat = new THREE.MeshLambertMaterial({ color: 0x2a3f5f });
        const ground = new THREE.Mesh(groundGeom, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // ===== ENEMY SYSTEM =====
        const enemies = [];
        function createEnemy() {
            const geom = new THREE.BoxGeometry(1, 2, 1);
            const mat = new THREE.MeshPhongMaterial({ color: Math.random() * 0xff0000 });
            const enemy = new THREE.Mesh(geom, mat);
            enemy.castShadow = true;
            enemy.receiveShadow = true;
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 20 + Math.random() * 30;
            enemy.position.set(Math.cos(angle) * distance, 1, Math.sin(angle) * distance);
            
            enemy.health = 20;
            enemy.speed = 0.02 + Math.random() * 0.02;
            enemy.hasDropped = false;

            scene.add(enemy);
            enemies.push(enemy);
        }

        function updateEnemies() {
            enemies.forEach((enemy, idx) => {
                if (enemy.health <= 0) {
                    if (!enemy.hasDropped) {
                        if (Math.random() > 0.6) spawnPowerup(enemy.position);
                        enemy.hasDropped = true;
                    }
                    scene.remove(enemy);
                    enemies.splice(idx, 1);
                    gameState.score += 100;
                    return;
                }

                const dir = new THREE.Vector3().subVectors(camera.position, enemy.position);
                dir.y = 0;
                dir.normalize();
                enemy.position.addScaledVector(dir, enemy.speed);
                
                if (enemy.position.distanceTo(camera.position) < 2) {
                    gameState.health -= 2;
                }
            });

            if (enemies.length < 3 && Math.random() > 0.98) {
                createEnemy();
            }
        }

        // ===== POWERUP SYSTEM =====
        const powerupObjects = [];
        const powerupList = [
            { name: "Health +50", effect: () => { gameState.health = Math.min(gameState.maxHealth, gameState.health + 50); } },
            { name: "Ammo +20", effect: () => { gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 20); } },
            { name: "Score x2", effect: () => { gameState.score *= 2; } },
            { name: "Shield", effect: () => { gameState.activePowerups.push({ name: "Shield (10s)", endTime: Date.now() + 10000 }); } }
        ];

        function spawnPowerup(position) {
            const powerup = powerupList[Math.floor(Math.random() * powerupList.length)];
            const geom = new THREE.SphereGeometry(0.4, 16, 16);
            const mat = new THREE.MeshPhongMaterial({ color: 0xFFD700, emissive: 0xFFD700, emissiveIntensity: 0.5 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(position);
            mesh.position.y = 1;
            mesh.powerupData = powerup;
            
            scene.add(mesh);
            powerupObjects.push({ mesh, powerup, time: 0 });
        }

        function updatePowerups() {
            powerupObjects.forEach((obj, idx) => {
                obj.time += 1;
                obj.mesh.rotation.y += 0.03;
                obj.mesh.position.y += Math.sin(obj.time * 0.05) * 0.002;

                const dist = obj.mesh.position.distanceTo(camera.position);
                if (dist < 2) {
                    obj.powerup.effect();
                    scene.remove(obj.mesh);
                    powerupObjects.splice(idx, 1);
                }

                if (obj.time > 600) {
                    scene.remove(obj.mesh);
                    powerupObjects.splice(idx, 1);
                }
            });

            gameState.activePowerups = gameState.activePowerups.filter(p => p.endTime > Date.now());
        }

        // ===== QUESTION SYSTEM =====
        function showQuestion() {
            if (gameState.questionActive) return;
            
            gameState.questionActive = true;
            const q = QUESTION_POOL[Math.floor(Math.random() * QUESTION_POOL.length)];
            gameState.currentQuestion = q;
            
            document.getElementById('questionText').textContent = q.q;
            document.getElementById('feedback').textContent = '';
            document.getElementById('feedback').className = '';
            
            const options = document.getElementById('optionsContainer');
            options.innerHTML = '';
            
            q.a.forEach((answer, idx) => {
                const btn = document.createElement('button');
                btn.className = 'option-button';
                btn.textContent = answer;
                btn.onclick = () => checkAnswer(idx);
                options.appendChild(btn);
            });
            
            document.getElementById('questionModal').classList.add('active');
        }

        function checkAnswer(idx) {
            const q = gameState.currentQuestion;
            const correct = idx === q.c;
            
            document.querySelectorAll('.option-button').forEach((btn, i) => {
                btn.disabled = true;
                if (i === q.c) btn.classList.add('correct');
                if (i === idx && i !== q.c) btn.classList.add('incorrect');
            });
            
            const feedback = document.getElementById('feedback');
            if (correct) {
                feedback.textContent = '✓ Correct! +20 Ammo';
                feedback.className = 'correct';
                gameState.ammo = Math.min(gameState.maxAmmo + 5, gameState.ammo + 20);
                gameState.correct++;
                gameState.score += 50;
                gameState.streak++;
                spawnPowerup(camera.position.clone().add(new THREE.Vector3(0, 2, -5)));
            } else {
                feedback.textContent = '✗ Wrong. -10 Health';
                feedback.className = 'incorrect';
                gameState.health -= 10;
                gameState.wrong++;
                gameState.streak = 0;
            }
            
            setTimeout(() => {
                document.getElementById('questionModal').classList.remove('active');
                gameState.questionActive = false;
            }, 2000);
        }

        // ===== TOUCH CONTROLS =====
        let touchInput = { x: 0, y: 0, looking: { x: 0, y: 0 } };
        
        document.getElementById('touchControls').addEventListener('touchstart', handleJoystickStart, false);
        document.getElementById('touchControls').addEventListener('touchmove', handleJoystickMove, false);
        document.getElementById('touchControls').addEventListener('touchend', handleJoystickEnd, false);

        function handleJoystickStart(e) {
            e.preventDefault();
        }

        function handleJoystickMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = document.getElementById('touchControls').getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            touchInput.x = (touch.clientX - centerX) / 60;
            touchInput.y = (touch.clientY - centerY) / 60;
        }

        function handleJoystickEnd(e) {
            e.preventDefault();
            touchInput.x = 0;
            touchInput.y = 0;
        }

        document.getElementById('lookPad').addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = document.getElementById('lookPad').getBoundingClientRect();
            
            touchInput.looking.x = (touch.clientX - rect.left - rect.width / 2) * 0.002;
            touchInput.looking.y = (touch.clientY - rect.top - rect.height / 2) * 0.002;
        });

        document.getElementById('shootButton').addEventListener('touchstart', (e) => {
            e.preventDefault();
            showQuestion();
        });

        // ===== PROJECTILE SYSTEM (Simplified) =====
        const projectiles = [];
        function createProjectile() {
            const geom = new THREE.SphereGeometry(0.2, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const proj = new THREE.Mesh(geom, mat);
            
            proj.position.copy(camera.position);
            proj.position.y -= 0.5;
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            proj.velocity = forward.multiplyScalar(0.5);
            proj.life = 100;

            scene.add(proj);
            projectiles.push(proj);
        }

        // ===== MAIN UPDATE LOOP =====
        function animate() {
            requestAnimationFrame(animate);

            // Player movement from touch
            const moveDir = new THREE.Vector3();
            moveDir.x = touchInput.x;
            moveDir.z = -touchInput.y;
            moveDir.applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            moveDir.y = 0;
            if (moveDir.length() > 0.1) {
                camera.position.addScaledVector(moveDir.normalize(), 0.1);
            }

            // Camera look
            camera.rotation.order = 'YXZ';
            camera.rotation.y -= touchInput.looking.x;
            camera.rotation.x -= touchInput.looking.y;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

            // Projectile updates
            projectiles.forEach((proj, idx) => {
                proj.position.addScaledVector(proj.velocity, 1);
                proj.life--;
                if (proj.life <= 0) {
                    scene.remove(proj);
                    projectiles.splice(idx, 1);
                }

                enemies.forEach((enemy) => {
                    if (proj.position.distanceTo(enemy.position) < 1.5) {
                        enemy.health -= 5;
                    }
                });
            });

            updateEnemies();
            updatePowerups();

            // UI Updates
            document.getElementById('health').textContent = Math.max(0, Math.ceil(gameState.health));
            document.getElementById('healthBar').style.width = (Math.max(0, gameState.health) / gameState.maxHealth * 100) + '%';
            document.getElementById('ammo').textContent = gameState.ammo;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('streak').textContent = gameState.streak;
            document.getElementById('enemyCount').textContent = enemies.length;
            document.getElementById('powerupCount').textContent = powerupObjects.length;
            document.getElementById('correct').textContent = gameState.correct;
            document.getElementById('wrong').textContent = gameState.wrong;

            const powerupsList = document.getElementById('powerupsList');
            powerupsList.innerHTML = gameState.activePowerups.map(p => {
                const remaining = Math.max(0, Math.ceil((p.endTime - Date.now()) / 1000));
                return '<div class="powerup-item">' + p.name + ' (' + remaining + 's)</div>';
            }).join('');

            if (gameState.health <= 0) {
                document.getElementById('gameMessage').textContent = 'GAME OVER! Final Score: ' + gameState.score;
                document.getElementById('gameMessage').style.display = 'block';
                return;
            }

            renderer.render(scene, camera);
        }

        // Initial setup
        for (let i = 0; i < 3; i++) createEnemy();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

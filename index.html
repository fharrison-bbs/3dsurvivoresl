<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ESL Powerup Arena - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            position: fixed;
            overflow: hidden;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #000;
            color: #fff;
        }
        
        #gameContainer {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        /* ===== TOUCH CONTROLS ===== */
        #touchControls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 130px;
            height: 130px;
            z-index: 10;
        }
        
        .joystick {
            width: 100%;
            height: 100%;
            background: rgba(0, 200, 255, 0.1);
            border: 3px solid rgba(0, 200, 255, 0.4);
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(0, 200, 255, 0.2);
        }
        
        .joystick-thumb {
            width: 55px;
            height: 55px;
            background: radial-gradient(circle at 30% 30%, rgba(0, 200, 255, 0.7), rgba(0, 150, 200, 0.5));
            border-radius: 50%;
            position: absolute;
            border: 2px solid #0cf;
            box-shadow: 0 0 15px rgba(0, 200, 255, 0.5);
        }
        
        #shootButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 90px;
            height: 90px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 100, 0, 0.4), rgba(255, 50, 0, 0.2));
            border: 3px solid #f60;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 10;
            color: #ff6600;
            text-shadow: 0 0 10px #f60;
            box-shadow: 0 0 25px rgba(255, 100, 0, 0.3);
        }
        
        #bombButton {
            position: absolute;
            bottom: 130px;
            right: 20px;
            width: 65px;
            height: 65px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 0, 100, 0.4), rgba(200, 0, 80, 0.2));
            border: 3px solid #f0a;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 10;
            box-shadow: 0 0 20px rgba(255, 0, 150, 0.3);
        }
        
        #lookPad {
            position: absolute;
            top: 50%;
            right: 160px;
            transform: translateY(-50%);
            width: 140px;
            height: 140px;
            background: rgba(100, 100, 255, 0.08);
            border: 2px solid rgba(100, 100, 255, 0.25);
            border-radius: 12px;
            z-index: 10;
        }
        
        /* ===== UI PANELS ===== */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.9));
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 12px;
            min-width: 180px;
            z-index: 5;
            border: 1px solid rgba(0, 200, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 100, 150, 0.3);
        }
        
        #stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, rgba(40, 0, 40, 0.95), rgba(60, 0, 60, 0.9));
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 11px;
            text-align: right;
            z-index: 5;
            border: 1px solid rgba(200, 0, 255, 0.3);
            box-shadow: 0 0 20px rgba(150, 0, 150, 0.3);
        }
        
        .stat-line {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }
        
        .stat-label {
            color: #aac;
        }
        
        .stat-value {
            color: #0ff;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }
        
        .health-bar {
            width: 150px;
            height: 14px;
            background: #222;
            border: 2px solid #444;
            margin-top: 6px;
            border-radius: 7px;
            overflow: hidden;
        }
        
        .health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #0a0);
            transition: width 0.3s;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
        }
        
        .ammo-bar {
            width: 150px;
            height: 10px;
            background: #222;
            border: 2px solid #444;
            margin-top: 4px;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .ammo-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0, #fa0);
            transition: width 0.3s;
        }
        
        /* ===== LEVEL INDICATOR ===== */
        #levelIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #00f;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        #levelIndicator.show {
            opacity: 1;
        }
        
        /* ===== QUESTION MODAL ===== */
        #questionModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.97);
            z-index: 100;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 15px;
        }
        
        #questionModal.active {
            display: flex;
        }
        
        #questionContainer {
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.98), rgba(0, 50, 80, 0.95));
            border: 3px solid #0cf;
            border-radius: 16px;
            padding: 25px;
            max-width: 95vw;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 200, 255, 0.3);
        }
        
        #questionCategory {
            font-size: 11px;
            color: #0cf;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            opacity: 0.8;
        }
        
        #questionText {
            font-size: 17px;
            margin-bottom: 20px;
            line-height: 1.5;
            color: #fff;
        }
        
        .option-button {
            width: 100%;
            padding: 14px 18px;
            margin: 8px 0;
            background: linear-gradient(135deg, rgba(0, 80, 100, 0.6), rgba(0, 60, 80, 0.4));
            border: 2px solid #0aa;
            color: #fff;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            touch-action: manipulation;
        }
        
        .option-button:active {
            background: rgba(0, 200, 255, 0.3);
            transform: scale(0.98);
        }
        
        .option-button.correct {
            background: linear-gradient(135deg, rgba(0, 180, 0, 0.8), rgba(0, 140, 0, 0.6));
            border-color: #0f0;
            color: #fff;
        }
        
        .option-button.incorrect {
            background: linear-gradient(135deg, rgba(200, 0, 0, 0.8), rgba(150, 0, 0, 0.6));
            border-color: #f00;
            color: #fff;
        }
        
        #feedback {
            margin-top: 18px;
            font-size: 15px;
            font-weight: bold;
            text-align: center;
            min-height: 30px;
        }
        
        #feedback.correct { color: #0f0; text-shadow: 0 0 15px #0f0; }
        #feedback.incorrect { color: #f44; text-shadow: 0 0 15px #f00; }
        
        /* ===== POWERUP DISPLAY ===== */
        #activePowerups {
            position: absolute;
            bottom: 210px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            max-width: 180px;
            font-size: 10px;
            z-index: 5;
            border: 1px solid rgba(255, 200, 0, 0.4);
        }
        
        .powerup-item {
            padding: 4px 8px;
            margin: 3px 0;
            background: rgba(255, 200, 0, 0.15);
            border-left: 3px solid #fd0;
            border-radius: 4px;
            color: #fd0;
        }
        
        /* ===== MINIMAP ===== */
        #minimap {
            position: absolute;
            bottom: 160px;
            left: 10px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #0aa;
            border-radius: 8px;
            z-index: 5;
            overflow: hidden;
        }
        
        #minimapCanvas {
            width: 100%;
            height: 100%;
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 2;
        }
        
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0, 255, 255, 0.8);
        }
        
        .crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        
        .crosshair::after {
            width: 20px;
            height: 2px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        
        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #0ff;
            border-radius: 50%;
            box-shadow: 0 0 10px #0ff;
        }
        
        #gameMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 0, 40, 0.95));
            border: 3px solid #f0a;
            padding: 30px 40px;
            border-radius: 16px;
            text-align: center;
            font-size: 20px;
            z-index: 50;
            display: none;
            box-shadow: 0 0 50px rgba(255, 0, 150, 0.4);
        }
        
        #restartBtn {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 16px;
            background: linear-gradient(135deg, #0a8, #086);
            border: 2px solid #0fa;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
        }
        
        /* ===== WARNING FLASH ===== */
        #damageFlash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(255, 0, 0, 0.4) 100%);
            pointer-events: none;
            z-index: 3;
            opacity: 0;
            transition: opacity 0.15s;
        }
        
        #damageFlash.active {
            opacity: 1;
        }
        
        /* ===== BOMB INDICATOR ===== */
        #bombCount {
            position: absolute;
            bottom: 200px;
            right: 25px;
            font-size: 14px;
            color: #f0a;
            font-weight: bold;
            z-index: 11;
            text-shadow: 0 0 10px #f0a;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="crosshair">
            <div class="crosshair-dot"></div>
        </div>
        
        <div id="damageFlash"></div>
        <div id="levelIndicator">LEVEL 1</div>
        
        <div id="ui">
            <div style="font-weight: bold; color: #0ff; margin-bottom: 8px; font-size: 14px;">üéÆ ESL ARENA</div>
            <div class="stat-line">
                <span class="stat-label">‚ù§Ô∏è Health</span>
                <span class="stat-value" id="health">100</span>
            </div>
            <div class="health-bar">
                <div class="health-bar-fill" id="healthBar" style="width: 100%"></div>
            </div>
            <div class="stat-line" style="margin-top: 8px;">
                <span class="stat-label">üî´ Ammo</span>
                <span class="stat-value" id="ammo">30</span>
            </div>
            <div class="ammo-bar">
                <div class="ammo-bar-fill" id="ammoBar" style="width: 100%"></div>
            </div>
            <div class="stat-line" style="margin-top: 8px;">
                <span class="stat-label">‚≠ê Score</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">üî• Streak</span>
                <span class="stat-value" id="streak">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">üìä Level</span>
                <span class="stat-value" id="level">1</span>
            </div>
        </div>
        
        <div id="stats">
            <div class="stat-line">
                <span class="stat-label">Enemies</span>
                <span class="stat-value" id="enemyCount">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">‚úì Correct</span>
                <span class="stat-value" style="color: #0f0;" id="correct">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">‚úó Wrong</span>
                <span class="stat-value" style="color: #f44;" id="wrong">0</span>
            </div>
        </div>
        
        <div id="activePowerups">
            <div style="font-weight: bold; color: #fd0; margin-bottom: 5px;">‚ö° ACTIVE</div>
            <div id="powerupsList"></div>
        </div>
        
        <div id="minimap">
            <canvas id="minimapCanvas"></canvas>
        </div>
        
        <div id="bombCount">üí£ x3</div>
        
        <!-- TOUCH CONTROLS -->
        <div id="touchControls">
            <div class="joystick">
                <div class="joystick-thumb"></div>
            </div>
        </div>
        
        <div id="lookPad"></div>
        <div id="shootButton">üéØ SHOOT</div>
        <div id="bombButton">üí£</div>
        
        <!-- QUESTION MODAL -->
        <div id="questionModal">
            <div id="questionContainer">
                <div id="questionCategory"></div>
                <div id="questionText"></div>
                <div id="optionsContainer"></div>
                <div id="feedback"></div>
            </div>
        </div>
        
        <div id="gameMessage">
            <div id="gameOverText"></div>
            <button id="restartBtn" onclick="location.reload()">üîÑ PLAY AGAIN</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ===== ESL QUESTION POOL - 30 Questions aligned with Grade 4 worksheet =====
        const QUESTION_POOL = [
            // VOCABULARY SECTION (10 questions matching fill-in-the-blank)
            { 
                q: "A _____ usually has a moral or a life lesson that helps us stay on a positive path in life.",
                a: ["fable", "poem", "dialogue", "sequence"],
                c: 0,
                cat: "Vocabulary - Stories"
            },
            { 
                q: "The water flowed from one side of town to the other in a very long _____.",
                a: ["river", "lake", "ocean", "pond"],
                c: 0,
                cat: "Vocabulary - Geography"
            },
            { 
                q: "In Egyptian culture, a person's remains are wrapped and kept in a case. They are called a _____.",
                a: ["mummy", "statue", "painting", "sarcophagus"],
                c: 0,
                cat: "Vocabulary - Ancient Egypt"
            },
            { 
                q: "_____ are used in a counting system that has been around for hundreds of years.",
                a: ["Roman numerals", "Binary codes", "Decimals", "Fractions"],
                c: 0,
                cat: "Vocabulary - Mathematics"
            },
            { 
                q: "The _____ was brave and honourable during his competition inside the colosseum.",
                a: ["gladiator", "pharaoh", "artist", "merchant"],
                c: 0,
                cat: "Vocabulary - Ancient Rome"
            },
            { 
                q: "One of the oldest _____ known to man are Aboriginals from Australia.",
                a: ["civilizations", "inventions", "buildings", "stories"],
                c: 0,
                cat: "Vocabulary - Cultures"
            },
            { 
                q: "Two people talking to each other is called _____.",
                a: ["dialogue", "monologue", "narrative", "description"],
                c: 0,
                cat: "Vocabulary - Language"
            },
            { 
                q: "Stories have a beginning, middle, and end. This _____ helps us follow the order of the story.",
                a: ["sequence", "dialogue", "moral", "setting"],
                c: 0,
                cat: "Vocabulary - Story Structure"
            },
            { 
                q: "Words such as 'but, so, and, next' are _____ that help tell a story.",
                a: ["connectives", "adjectives", "nouns", "verbs"],
                c: 0,
                cat: "Vocabulary - Grammar"
            },
            { 
                q: "_____ are used in stories to help compare two things, often using the words 'like' or 'as'.",
                a: ["Similes", "Metaphors", "Fables", "Dialogues"],
                c: 0,
                cat: "Vocabulary - Literary Devices"
            },

            // KING TUT'S TOMB - TRUE/FALSE (5 questions)
            { 
                q: "TRUE or FALSE: More than 3,000 treasures were found in King Tutankhamun's tomb.",
                a: ["TRUE", "FALSE"],
                c: 0,
                cat: "King Tut's Tomb"
            },
            { 
                q: "TRUE or FALSE: Some believe Tutankhamun died from an infection in a broken leg.",
                a: ["TRUE", "FALSE"],
                c: 0,
                cat: "King Tut's Tomb"
            },
            { 
                q: "TRUE or FALSE: Tutankhamun became Pharaoh when his father died.",
                a: ["TRUE", "FALSE"],
                c: 0,
                cat: "King Tut's Tomb"
            },
            { 
                q: "TRUE or FALSE: Howard Carter said 'It was like entering a machine.'",
                a: ["FALSE - He said 'time machine'", "TRUE"],
                c: 0,
                cat: "King Tut's Tomb"
            },
            { 
                q: "TRUE or FALSE: Some people think Tutankhamun died from a blow to the head.",
                a: ["TRUE", "FALSE"],
                c: 0,
                cat: "King Tut's Tomb"
            },

            // ABORIGINAL ART (10 questions based on passage)
            { 
                q: "According to the passage, how old is the oldest Aboriginal artwork ever found?",
                a: ["About 40,000 years old", "About 10,000 years old", "About 125,000 years old", "About 5,000 years old"],
                c: 0,
                cat: "Aboriginal Art"
            },
            { 
                q: "What natural resources did Aboriginal people use to produce colours like white, yellow, and red?",
                a: ["Ochre and clay", "Paint and dye", "Flowers and leaves", "Metal and stone"],
                c: 0,
                cat: "Aboriginal Art"
            },
            { 
                q: "In Aboriginal dot painting, what does the yellow dot represent?",
                a: ["The sun", "The desert sand", "The soil", "The clouds"],
                c: 0,
                cat: "Aboriginal Art"
            },
            { 
                q: "Why did Aboriginal people use dots, circles, lines, and symbols in their art?",
                a: ["To hide secret messages from Europeans", "To make the art more colourful", "Because they couldn't paint properly", "To copy European styles"],
                c: 0,
                cat: "Aboriginal Art"
            },
            { 
                q: "What is ONE purpose of Aboriginal art mentioned in the passage?",
                a: ["To tell a story", "To sell to tourists", "To decorate buildings", "To make money"],
                c: 0,
                cat: "Aboriginal Art"
            },
            { 
                q: "What material did Aboriginal artists use to make BLACK colour?",
                a: ["Charcoal", "Clay", "Ochre", "Bark"],
                c: 0,
                cat: "Aboriginal Art"
            },
            { 
                q: "What colour represents the red desert sand in Aboriginal art?",
                a: ["Red", "Yellow", "Brown", "White"],
                c: 0,
                cat: "Aboriginal Art"
            },
            { 
                q: "Aboriginal art was used to educate children about:",
                a: ["Animals and nature", "Mathematics", "Writing", "European culture"],
                c: 0,
                cat: "Aboriginal Art"
            },
            { 
                q: "What does WHITE represent in Aboriginal dot painting?",
                a: ["Clouds and sky", "Desert sand", "The sun", "Water"],
                c: 0,
                cat: "Aboriginal Art"
            },
            { 
                q: "Aboriginal people painted on which surfaces?",
                a: ["Rocks and bark", "Canvas and paper", "Metal sheets", "Glass windows"],
                c: 0,
                cat: "Aboriginal Art"
            },

            // ADDITIONAL COMPREHENSION (5 questions)
            { 
                q: "When was King Tutankhamun's tomb discovered?",
                a: ["24th November 1922", "24th November 1920", "24th December 1922", "24th October 1922"],
                c: 0,
                cat: "King Tut's Tomb"
            },
            { 
                q: "How old was Tutankhamun when he became Pharaoh?",
                a: ["9 years old", "12 years old", "18 years old", "5 years old"],
                c: 0,
                cat: "King Tut's Tomb"
            },
            { 
                q: "Who discovered King Tutankhamun's tomb?",
                a: ["Howard Carter", "Napoleon Bonaparte", "King George", "Indiana Jones"],
                c: 0,
                cat: "King Tut's Tomb"
            },
            { 
                q: "What game was found in Tutankhamun's tomb?",
                a: ["Senet", "Chess", "Checkers", "Cards"],
                c: 0,
                cat: "King Tut's Tomb"
            },
            { 
                q: "How long have Aboriginal people lived in Australia according to historians?",
                a: ["About 125,000 years", "About 40,000 years", "About 10,000 years", "About 5,000 years"],
                c: 0,
                cat: "Aboriginal Art"
            }
        ];

        // Shuffle questions
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        let shuffledQuestions = shuffleArray([...QUESTION_POOL]);
        let questionIndex = 0;

        // ===== GAME STATE =====
        const gameState = {
            health: 100,
            maxHealth: 100,
            ammo: 30,
            maxAmmo: 50,
            bombs: 3,
            maxBombs: 5,
            score: 0,
            streak: 0,
            correct: 0,
            wrong: 0,
            level: 1,
            activePowerups: [],
            questionActive: false,
            currentQuestion: null,
            gameOver: false,
            shieldActive: false,
            speedMultiplier: 1,
            damageMultiplier: 1
        };

        // ===== THREE.JS SETUP =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        scene.fog = new THREE.FogExp2(0x0a0a1a, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('gameContainer').appendChild(renderer.domElement);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.left = '0';
        renderer.domElement.style.zIndex = '1';

        // ===== LIGHTING =====
        const ambientLight = new THREE.AmbientLight(0x4466aa, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(30, 50, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 200;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        // Colored point lights for atmosphere
        const pointLight1 = new THREE.PointLight(0x00ffff, 0.5, 50);
        pointLight1.position.set(-20, 10, -20);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff00ff, 0.5, 50);
        pointLight2.position.set(20, 10, 20);
        scene.add(pointLight2);

        // ===== LEVEL GENERATION =====
        const levelObjects = [];
        const traps = [];
        const ARENA_SIZE = 80;

        function generateLevel(level) {
            // Clear old level objects
            levelObjects.forEach(obj => scene.remove(obj));
            levelObjects.length = 0;
            traps.forEach(t => scene.remove(t.mesh));
            traps.length = 0;

            // Ground with grid pattern
            const groundGeom = new THREE.PlaneGeometry(ARENA_SIZE * 2, ARENA_SIZE * 2, 40, 40);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a2a3a,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            levelObjects.push(ground);

            // Grid lines
            const gridHelper = new THREE.GridHelper(ARENA_SIZE * 2, 40, 0x00ffff, 0x003344);
            gridHelper.position.y = 0.05;
            scene.add(gridHelper);
            levelObjects.push(gridHelper);

            // Arena walls
            const wallMat = new THREE.MeshStandardMaterial({ 
                color: 0x2244aa, 
                emissive: 0x001144,
                emissiveIntensity: 0.3,
                roughness: 0.4
            });

            const wallPositions = [
                { x: 0, z: -ARENA_SIZE, rotY: 0 },
                { x: 0, z: ARENA_SIZE, rotY: 0 },
                { x: -ARENA_SIZE, z: 0, rotY: Math.PI/2 },
                { x: ARENA_SIZE, z: 0, rotY: Math.PI/2 }
            ];

            wallPositions.forEach(pos => {
                const wallGeom = new THREE.BoxGeometry(ARENA_SIZE * 2, 8, 2);
                const wall = new THREE.Mesh(wallGeom, wallMat);
                wall.position.set(pos.x, 4, pos.z);
                wall.rotation.y = pos.rotY;
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                levelObjects.push(wall);
            });

            // Obstacles based on level
            const obstacleCount = 5 + level * 2;
            const obstacleMat = new THREE.MeshStandardMaterial({ 
                color: 0x445566,
                roughness: 0.6,
                metalness: 0.4
            });

            for (let i = 0; i < obstacleCount; i++) {
                const size = 2 + Math.random() * 4;
                const height = 2 + Math.random() * 6;
                let geom;
                
                const shapeType = Math.floor(Math.random() * 3);
                if (shapeType === 0) {
                    geom = new THREE.BoxGeometry(size, height, size);
                } else if (shapeType === 1) {
                    geom = new THREE.CylinderGeometry(size/2, size/2, height, 8);
                } else {
                    geom = new THREE.ConeGeometry(size/2, height, 6);
                }

                const obstacle = new THREE.Mesh(geom, obstacleMat);
                obstacle.position.set(
                    (Math.random() - 0.5) * (ARENA_SIZE - 20),
                    height / 2,
                    (Math.random() - 0.5) * (ARENA_SIZE - 20)
                );
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                scene.add(obstacle);
                levelObjects.push(obstacle);
            }

            // Generate traps (spike zones)
            const trapCount = Math.min(level + 1, 6);
            for (let i = 0; i < trapCount; i++) {
                createTrap();
            }

            // Glowing pillars
            const pillarMat = new THREE.MeshStandardMaterial({ 
                color: 0x00ffaa, 
                emissive: 0x00ff88,
                emissiveIntensity: 0.5
            });

            for (let i = 0; i < 4; i++) {
                const pillarGeom = new THREE.CylinderGeometry(1.5, 1.5, 15, 8);
                const pillar = new THREE.Mesh(pillarGeom, pillarMat);
                const angle = (i / 4) * Math.PI * 2;
                pillar.position.set(
                    Math.cos(angle) * (ARENA_SIZE - 15),
                    7.5,
                    Math.sin(angle) * (ARENA_SIZE - 15)
                );
                pillar.castShadow = true;
                scene.add(pillar);
                levelObjects.push(pillar);
            }
        }

        // ===== TRAP SYSTEM =====
        function createTrap() {
            const trapGeom = new THREE.CircleGeometry(4, 16);
            const trapMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0044,
                transparent: true,
                opacity: 0.4
            });
            const trap = new THREE.Mesh(trapGeom, trapMat);
            trap.rotation.x = -Math.PI / 2;
            trap.position.set(
                (Math.random() - 0.5) * (ARENA_SIZE - 30),
                0.1,
                (Math.random() - 0.5) * (ARENA_SIZE - 30)
            );
            
            // Spike mesh
            const spikesGroup = new THREE.Group();
            const spikeMat = new THREE.MeshStandardMaterial({ color: 0xaa0033 });
            
            for (let i = 0; i < 8; i++) {
                const spikeGeom = new THREE.ConeGeometry(0.3, 1.5, 4);
                const spike = new THREE.Mesh(spikeGeom, spikeMat);
                const angle = (i / 8) * Math.PI * 2;
                spike.position.set(Math.cos(angle) * 2, 0, Math.sin(angle) * 2);
                spikesGroup.add(spike);
            }
            spikesGroup.position.copy(trap.position);
            spikesGroup.position.y = -1;
            
            scene.add(trap);
            scene.add(spikesGroup);
            
            traps.push({
                mesh: trap,
                spikes: spikesGroup,
                active: false,
                timer: 0,
                cooldown: 0
            });
        }

        function updateTraps() {
            traps.forEach(trap => {
                const dist = new THREE.Vector2(
                    camera.position.x - trap.mesh.position.x,
                    camera.position.z - trap.mesh.position.z
                ).length();

                trap.timer++;
                
                if (dist < 4 && trap.cooldown <= 0) {
                    trap.active = true;
                    trap.cooldown = 180; // 3 second cooldown
                }

                if (trap.active) {
                    trap.spikes.position.y = Math.min(trap.spikes.position.y + 0.2, 0.5);
                    if (trap.spikes.position.y >= 0.5 && dist < 4) {
                        if (!gameState.shieldActive) {
                            gameState.health -= 1;
                            showDamageFlash();
                        }
                    }
                    if (trap.timer % 60 === 0) {
                        trap.active = false;
                    }
                } else {
                    trap.spikes.position.y = Math.max(trap.spikes.position.y - 0.1, -1);
                }

                if (trap.cooldown > 0) trap.cooldown--;

                // Pulse effect
                trap.mesh.material.opacity = 0.3 + Math.sin(trap.timer * 0.1) * 0.1;
            });
        }

        // ===== ENEMY SYSTEM WITH VARIETY =====
        const enemies = [];
        const ENEMY_TYPES = {
            BASIC: {
                name: 'Basic',
                color: 0xff3333,
                health: 15,
                speed: 0.03,
                damage: 2,
                size: { w: 1, h: 2, d: 1 },
                score: 100
            },
            FAST: {
                name: 'Fast',
                color: 0xffff00,
                health: 8,
                speed: 0.07,
                damage: 1,
                size: { w: 0.7, h: 1.5, d: 0.7 },
                score: 150
            },
            TANK: {
                name: 'Tank',
                color: 0x8844ff,
                health: 40,
                speed: 0.015,
                damage: 5,
                size: { w: 1.8, h: 2.5, d: 1.8 },
                score: 250
            },
            RANGED: {
                name: 'Ranged',
                color: 0x00ff88,
                health: 12,
                speed: 0.02,
                damage: 3,
                size: { w: 1, h: 2.2, d: 1 },
                score: 200,
                ranged: true,
                fireRate: 120
            },
            BOSS: {
                name: 'Boss',
                color: 0xff00ff,
                health: 100,
                speed: 0.025,
                damage: 8,
                size: { w: 3, h: 4, d: 3 },
                score: 1000
            }
        };

        function createEnemy(type = null) {
            // Choose type based on level and randomness
            if (!type) {
                const rand = Math.random();
                const level = gameState.level;
                
                if (rand < 0.4) {
                    type = ENEMY_TYPES.BASIC;
                } else if (rand < 0.6) {
                    type = ENEMY_TYPES.FAST;
                } else if (rand < 0.75 && level >= 2) {
                    type = ENEMY_TYPES.TANK;
                } else if (rand < 0.9 && level >= 3) {
                    type = ENEMY_TYPES.RANGED;
                } else {
                    type = ENEMY_TYPES.BASIC;
                }
            }

            const geom = new THREE.BoxGeometry(type.size.w, type.size.h, type.size.d);
            const mat = new THREE.MeshStandardMaterial({ 
                color: type.color,
                emissive: type.color,
                emissiveIntensity: 0.3,
                roughness: 0.5
            });
            const enemy = new THREE.Mesh(geom, mat);
            enemy.castShadow = true;
            enemy.receiveShadow = true;

            // Spawn at random position at edge of arena
            const angle = Math.random() * Math.PI * 2;
            const distance = ARENA_SIZE - 10;
            enemy.position.set(
                Math.cos(angle) * distance,
                type.size.h / 2,
                Math.sin(angle) * distance
            );

            // Enemy properties
            enemy.enemyType = type;
            enemy.health = type.health;
            enemy.maxHealth = type.health;
            enemy.speed = type.speed;
            enemy.damage = type.damage;
            enemy.hasDropped = false;
            enemy.fireTimer = 0;

            // Health bar
            const hbGeom = new THREE.PlaneGeometry(2, 0.2);
            const hbMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const healthBar = new THREE.Mesh(hbGeom, hbMat);
            healthBar.position.y = type.size.h / 2 + 0.5;
            enemy.add(healthBar);
            enemy.healthBar = healthBar;

            scene.add(enemy);
            enemies.push(enemy);
        }

        function createBoss() {
            createEnemy(ENEMY_TYPES.BOSS);
        }

        const enemyProjectiles = [];

        function updateEnemies() {
            enemies.forEach((enemy, idx) => {
                if (enemy.health <= 0) {
                    // Death particles
                    createExplosion(enemy.position, enemy.enemyType.color, 15);
                    
                    if (!enemy.hasDropped) {
                        if (Math.random() > 0.5) spawnPowerup(enemy.position);
                        enemy.hasDropped = true;
                    }
                    scene.remove(enemy);
                    enemies.splice(idx, 1);
                    gameState.score += enemy.enemyType.score;
                    return;
                }

                // Update health bar
                const healthPercent = enemy.health / enemy.maxHealth;
                enemy.healthBar.scale.x = healthPercent;
                enemy.healthBar.material.color.setHex(healthPercent > 0.5 ? 0x00ff00 : (healthPercent > 0.25 ? 0xffff00 : 0xff0000));
                enemy.healthBar.lookAt(camera.position);

                // Movement
                const dir = new THREE.Vector3().subVectors(camera.position, enemy.position);
                dir.y = 0;
                
                // Ranged enemies keep distance
                if (enemy.enemyType.ranged) {
                    if (dir.length() < 15) {
                        dir.negate();
                    } else if (dir.length() > 25) {
                        dir.normalize();
                        enemy.position.addScaledVector(dir, enemy.speed);
                    }
                    
                    // Shoot at player
                    enemy.fireTimer++;
                    if (enemy.fireTimer >= enemy.enemyType.fireRate) {
                        enemy.fireTimer = 0;
                        createEnemyProjectile(enemy.position.clone(), camera.position.clone());
                    }
                } else {
                    dir.normalize();
                    enemy.position.addScaledVector(dir, enemy.speed);
                }

                // Collision with player
                if (enemy.position.distanceTo(camera.position) < 2) {
                    if (!gameState.shieldActive) {
                        gameState.health -= enemy.damage * 0.1;
                        showDamageFlash();
                    }
                }

                // Animation
                enemy.rotation.y += 0.02;
            });

            // Update enemy projectiles
            enemyProjectiles.forEach((proj, idx) => {
                proj.position.addScaledVector(proj.velocity, 1);
                proj.life--;

                if (proj.life <= 0) {
                    scene.remove(proj);
                    enemyProjectiles.splice(idx, 1);
                    return;
                }

                if (proj.position.distanceTo(camera.position) < 1.5) {
                    if (!gameState.shieldActive) {
                        gameState.health -= 5;
                        showDamageFlash();
                    }
                    scene.remove(proj);
                    enemyProjectiles.splice(idx, 1);
                }
            });

            // Spawn new enemies
            const maxEnemies = 3 + gameState.level * 2;
            if (enemies.length < maxEnemies && Math.random() > 0.98) {
                createEnemy();
            }
        }

        function createEnemyProjectile(from, to) {
            const geom = new THREE.SphereGeometry(0.3, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const proj = new THREE.Mesh(geom, mat);
            proj.position.copy(from);
            proj.position.y = 1.5;
            
            const dir = new THREE.Vector3().subVectors(to, from).normalize();
            proj.velocity = dir.multiplyScalar(0.3);
            proj.life = 150;
            
            scene.add(proj);
            enemyProjectiles.push(proj);
        }

        // ===== POWERUP SYSTEM =====
        const powerupObjects = [];
        const POWERUP_TYPES = [
            { 
                name: "‚ù§Ô∏è Health +30", 
                color: 0xff4444,
                effect: () => { 
                    gameState.health = Math.min(gameState.maxHealth, gameState.health + 30); 
                } 
            },
            { 
                name: "üî´ Ammo +15", 
                color: 0xffff00,
                effect: () => { 
                    gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 15); 
                } 
            },
            { 
                name: "üõ°Ô∏è Shield (8s)", 
                color: 0x4488ff,
                effect: () => { 
                    gameState.shieldActive = true;
                    gameState.activePowerups.push({ 
                        name: "üõ°Ô∏è Shield", 
                        endTime: Date.now() + 8000,
                        onEnd: () => { gameState.shieldActive = false; }
                    }); 
                } 
            },
            { 
                name: "‚ö° Speed x2 (10s)", 
                color: 0x00ffff,
                effect: () => { 
                    gameState.speedMultiplier = 2;
                    gameState.activePowerups.push({ 
                        name: "‚ö° Speed", 
                        endTime: Date.now() + 10000,
                        onEnd: () => { gameState.speedMultiplier = 1; }
                    }); 
                } 
            },
            { 
                name: "üí• Damage x2 (12s)", 
                color: 0xff8800,
                effect: () => { 
                    gameState.damageMultiplier = 2;
                    gameState.activePowerups.push({ 
                        name: "üí• Damage", 
                        endTime: Date.now() + 12000,
                        onEnd: () => { gameState.damageMultiplier = 1; }
                    }); 
                } 
            },
            { 
                name: "üí£ +1 Bomb", 
                color: 0xff00aa,
                effect: () => { 
                    gameState.bombs = Math.min(gameState.maxBombs, gameState.bombs + 1); 
                } 
            },
            { 
                name: "‚≠ê Score x2", 
                color: 0xffdd00,
                effect: () => { 
                    gameState.score *= 2; 
                } 
            },
            { 
                name: "‚ùÑÔ∏è Freeze (5s)", 
                color: 0x88ffff,
                effect: () => { 
                    enemies.forEach(e => {
                        e.originalSpeed = e.speed;
                        e.speed = 0;
                    });
                    gameState.activePowerups.push({ 
                        name: "‚ùÑÔ∏è Freeze", 
                        endTime: Date.now() + 5000,
                        onEnd: () => { 
                            enemies.forEach(e => {
                                if (e.originalSpeed) e.speed = e.originalSpeed;
                            });
                        }
                    }); 
                } 
            }
        ];

        function spawnPowerup(position) {
            const powerup = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
            
            // Outer glow
            const glowGeom = new THREE.SphereGeometry(0.8, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: powerup.color, 
                transparent: true, 
                opacity: 0.3 
            });
            const glow = new THREE.Mesh(glowGeom, glowMat);
            
            // Inner core
            const coreGeom = new THREE.OctahedronGeometry(0.4, 0);
            const coreMat = new THREE.MeshStandardMaterial({ 
                color: powerup.color, 
                emissive: powerup.color,
                emissiveIntensity: 0.8,
                metalness: 0.8,
                roughness: 0.2
            });
            const core = new THREE.Mesh(coreGeom, coreMat);
            
            const group = new THREE.Group();
            group.add(glow);
            group.add(core);
            group.position.copy(position);
            group.position.y = 1.5;
            group.powerupData = powerup;
            
            scene.add(group);
            powerupObjects.push({ mesh: group, powerup, time: 0 });
        }

        function updatePowerups() {
            powerupObjects.forEach((obj, idx) => {
                obj.time += 1;
                obj.mesh.rotation.y += 0.04;
                obj.mesh.children[1].rotation.x += 0.03;
                obj.mesh.position.y = 1.5 + Math.sin(obj.time * 0.06) * 0.3;

                const dist = obj.mesh.position.distanceTo(camera.position);
                if (dist < 2.5) {
                    obj.powerup.effect();
                    createParticleBurst(obj.mesh.position, obj.powerup.color, 20);
                    scene.remove(obj.mesh);
                    powerupObjects.splice(idx, 1);
                }

                if (obj.time > 600) {
                    scene.remove(obj.mesh);
                    powerupObjects.splice(idx, 1);
                }
            });

            // Update active powerups
            gameState.activePowerups = gameState.activePowerups.filter(p => {
                if (p.endTime <= Date.now()) {
                    if (p.onEnd) p.onEnd();
                    return false;
                }
                return true;
            });
        }

        // ===== PARTICLE SYSTEM =====
        const particles = [];

        function createParticle(position, color, velocity, life = 60) {
            const geom = new THREE.SphereGeometry(0.1, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color, transparent: true });
            const particle = new THREE.Mesh(geom, mat);
            particle.position.copy(position);
            particle.velocity = velocity;
            particle.life = life;
            particle.maxLife = life;
            scene.add(particle);
            particles.push(particle);
        }

        function createParticleBurst(position, color, count) {
            for (let i = 0; i < count; i++) {
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.3
                );
                createParticle(position.clone(), color, velocity, 40 + Math.random() * 30);
            }
        }

        function createExplosion(position, color, count) {
            for (let i = 0; i < count; i++) {
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.4,
                    (Math.random() - 0.5) * 0.5
                );
                createParticle(position.clone(), color, velocity, 50);
            }
            
            // Shockwave ring
            const ringGeom = new THREE.RingGeometry(0.5, 0.7, 16);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide 
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.position.copy(position);
            ring.position.y = 0.1;
            ring.rotation.x = -Math.PI / 2;
            ring.scale.set(1, 1, 1);
            ring.userData = { expanding: true, life: 30 };
            scene.add(ring);
            particles.push(ring);
        }

        function createMuzzleFlash(position, direction) {
            for (let i = 0; i < 5; i++) {
                const velocity = direction.clone().multiplyScalar(0.2);
                velocity.x += (Math.random() - 0.5) * 0.1;
                velocity.y += (Math.random() - 0.5) * 0.1;
                velocity.z += (Math.random() - 0.5) * 0.1;
                createParticle(position.clone(), 0x00ff00, velocity, 15);
            }
        }

        function updateParticles() {
            particles.forEach((p, idx) => {
                if (p.userData && p.userData.expanding) {
                    // Shockwave ring
                    p.scale.x += 0.5;
                    p.scale.y += 0.5;
                    p.material.opacity -= 0.03;
                    p.userData.life--;
                    if (p.userData.life <= 0) {
                        scene.remove(p);
                        particles.splice(idx, 1);
                    }
                } else {
                    p.position.add(p.velocity);
                    p.velocity.y -= 0.005; // gravity
                    p.life--;
                    p.material.opacity = p.life / p.maxLife;
                    
                    if (p.life <= 0) {
                        scene.remove(p);
                        particles.splice(idx, 1);
                    }
                }
            });
        }

        // ===== BOMB SYSTEM =====
        const bombs = [];

        function dropBomb() {
            if (gameState.bombs <= 0) return;
            gameState.bombs--;
            
            const bombGeom = new THREE.SphereGeometry(0.5, 16, 16);
            const bombMat = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                emissive: 0xff0044,
                emissiveIntensity: 0.5
            });
            const bomb = new THREE.Mesh(bombGeom, bombMat);
            bomb.position.copy(camera.position);
            bomb.position.y = 0.5;
            bomb.timer = 120; // 2 seconds
            
            scene.add(bomb);
            bombs.push(bomb);
        }

        function updateBombs() {
            bombs.forEach((bomb, idx) => {
                bomb.timer--;
                
                // Pulsing glow
                bomb.material.emissiveIntensity = 0.5 + Math.sin(bomb.timer * 0.3) * 0.3;
                
                if (bomb.timer <= 0) {
                    // EXPLOSION!
                    createExplosion(bomb.position, 0xff4400, 40);
                    
                    // Damage enemies in radius
                    enemies.forEach(enemy => {
                        const dist = enemy.position.distanceTo(bomb.position);
                        if (dist < 12) {
                            const damage = 30 * (1 - dist / 12);
                            enemy.health -= damage;
                        }
                    });
                    
                    scene.remove(bomb);
                    bombs.splice(idx, 1);
                }
            });
            
            document.getElementById('bombCount').textContent = `üí£ x${gameState.bombs}`;
        }

        // ===== PROJECTILE SYSTEM =====
        const projectiles = [];

        function createProjectile() {
            if (gameState.ammo <= 0) {
                // Trigger question to get more ammo
                showQuestion();
                return;
            }
            
            gameState.ammo--;

            const geom = new THREE.SphereGeometry(0.15, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const proj = new THREE.Mesh(geom, mat);
            
            proj.position.copy(camera.position);
            proj.position.y -= 0.3;
            
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            proj.velocity = forward.multiplyScalar(0.8);
            proj.life = 80;

            // Muzzle flash
            createMuzzleFlash(proj.position.clone(), forward);

            scene.add(proj);
            projectiles.push(proj);
        }

        function updateProjectiles() {
            projectiles.forEach((proj, idx) => {
                proj.position.add(proj.velocity);
                proj.life--;

                if (proj.life <= 0) {
                    scene.remove(proj);
                    projectiles.splice(idx, 1);
                    return;
                }

                // Check enemy hits
                enemies.forEach(enemy => {
                    if (proj.position.distanceTo(enemy.position) < 1.5) {
                        enemy.health -= 5 * gameState.damageMultiplier;
                        createParticleBurst(proj.position, 0x00ff00, 8);
                        scene.remove(proj);
                        projectiles.splice(idx, 1);
                    }
                });
            });
        }

        // ===== QUESTION SYSTEM =====
        function showQuestion() {
            if (gameState.questionActive || gameState.gameOver) return;
            
            gameState.questionActive = true;
            
            // Get next question
            if (questionIndex >= shuffledQuestions.length) {
                shuffledQuestions = shuffleArray([...QUESTION_POOL]);
                questionIndex = 0;
            }
            
            const q = shuffledQuestions[questionIndex++];
            gameState.currentQuestion = q;
            
            document.getElementById('questionCategory').textContent = q.cat;
            document.getElementById('questionText').textContent = q.q;
            document.getElementById('feedback').textContent = '';
            document.getElementById('feedback').className = '';
            
            const options = document.getElementById('optionsContainer');
            options.innerHTML = '';
            
            q.a.forEach((answer, idx) => {
                const btn = document.createElement('button');
                btn.className = 'option-button';
                btn.textContent = answer;
                btn.onclick = () => checkAnswer(idx);
                options.appendChild(btn);
            });
            
            document.getElementById('questionModal').classList.add('active');
        }

        function checkAnswer(idx) {
            const q = gameState.currentQuestion;
            const correct = idx === q.c;
            
            document.querySelectorAll('.option-button').forEach((btn, i) => {
                btn.disabled = true;
                if (i === q.c) btn.classList.add('correct');
                if (i === idx && i !== q.c) btn.classList.add('incorrect');
            });
            
            const feedback = document.getElementById('feedback');
            if (correct) {
                feedback.textContent = '‚úì Correct! +20 Ammo, +50 Points';
                feedback.className = 'correct';
                gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 20);
                gameState.correct++;
                gameState.score += 50;
                gameState.streak++;
                
                // Bonus for streak
                if (gameState.streak >= 3) {
                    feedback.textContent += ` | üî• Streak Bonus! +${gameState.streak * 10}`;
                    gameState.score += gameState.streak * 10;
                }
                
                // Spawn powerup on correct answer
                const offset = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    0,
                    (Math.random() - 0.5) * 10
                );
                spawnPowerup(camera.position.clone().add(offset));
            } else {
                feedback.textContent = '‚úó Wrong! -15 Health';
                feedback.className = 'incorrect';
                gameState.health -= 15;
                gameState.wrong++;
                gameState.streak = 0;
                showDamageFlash();
            }
            
            setTimeout(() => {
                document.getElementById('questionModal').classList.remove('active');
                gameState.questionActive = false;
            }, 2000);
        }

        // ===== DAMAGE FLASH =====
        function showDamageFlash() {
            const flash = document.getElementById('damageFlash');
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 150);
        }

        // ===== TOUCH CONTROLS =====
        let touchInput = { x: 0, y: 0, looking: { x: 0, y: 0 } };
        const joystickThumb = document.querySelector('.joystick-thumb');
        const joystickBase = document.getElementById('touchControls');
        let joystickTouch = null;

        joystickBase.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickTouch = e.touches[0].identifier;
        }, { passive: false });

        joystickBase.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let touch of e.touches) {
                if (touch.identifier === joystickTouch) {
                    const rect = joystickBase.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    let dx = touch.clientX - centerX;
                    let dy = touch.clientY - centerY;
                    
                    const maxDist = rect.width / 2 - 25;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > maxDist) {
                        dx = (dx / dist) * maxDist;
                        dy = (dy / dist) * maxDist;
                    }
                    
                    joystickThumb.style.transform = `translate(${dx}px, ${dy}px)`;
                    
                    touchInput.x = dx / maxDist;
                    touchInput.y = dy / maxDist;
                }
            }
        }, { passive: false });

        joystickBase.addEventListener('touchend', (e) => {
            e.preventDefault();
            let found = false;
            for (let touch of e.touches) {
                if (touch.identifier === joystickTouch) found = true;
            }
            if (!found) {
                joystickTouch = null;
                joystickThumb.style.transform = 'translate(0, 0)';
                touchInput.x = 0;
                touchInput.y = 0;
            }
        }, { passive: false });

        // Look pad
        let lookTouch = null;
        let lastLookPos = { x: 0, y: 0 };

        document.getElementById('lookPad').addEventListener('touchstart', (e) => {
            e.preventDefault();
            lookTouch = e.touches[0].identifier;
            lastLookPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }, { passive: false });

        document.getElementById('lookPad').addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let touch of e.touches) {
                if (touch.identifier === lookTouch) {
                    touchInput.looking.x = (touch.clientX - lastLookPos.x) * 0.004;
                    touchInput.looking.y = (touch.clientY - lastLookPos.y) * 0.004;
                    lastLookPos = { x: touch.clientX, y: touch.clientY };
                }
            }
        }, { passive: false });

        document.getElementById('lookPad').addEventListener('touchend', (e) => {
            e.preventDefault();
            lookTouch = null;
            touchInput.looking.x = 0;
            touchInput.looking.y = 0;
        }, { passive: false });

        // Shoot button
        document.getElementById('shootButton').addEventListener('touchstart', (e) => {
            e.preventDefault();
            createProjectile();
        }, { passive: false });

        // Bomb button
        document.getElementById('bombButton').addEventListener('touchstart', (e) => {
            e.preventDefault();
            dropBomb();
        }, { passive: false });

        // ===== MINIMAP =====
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 100;
        minimapCanvas.height = 100;

        function updateMinimap() {
            minimapCtx.fillStyle = 'rgba(0, 20, 40, 0.9)';
            minimapCtx.fillRect(0, 0, 100, 100);
            
            const scale = 100 / (ARENA_SIZE * 2);
            const offsetX = 50;
            const offsetY = 50;
            
            // Draw enemies
            enemies.forEach(enemy => {
                minimapCtx.fillStyle = '#ff3333';
                minimapCtx.beginPath();
                minimapCtx.arc(
                    enemy.position.x * scale + offsetX,
                    enemy.position.z * scale + offsetY,
                    3, 0, Math.PI * 2
                );
                minimapCtx.fill();
            });
            
            // Draw powerups
            powerupObjects.forEach(p => {
                minimapCtx.fillStyle = '#ffff00';
                minimapCtx.beginPath();
                minimapCtx.arc(
                    p.mesh.position.x * scale + offsetX,
                    p.mesh.position.z * scale + offsetY,
                    2, 0, Math.PI * 2
                );
                minimapCtx.fill();
            });
            
            // Draw player
            minimapCtx.fillStyle = '#00ffff';
            minimapCtx.beginPath();
            minimapCtx.arc(
                camera.position.x * scale + offsetX,
                camera.position.z * scale + offsetY,
                4, 0, Math.PI * 2
            );
            minimapCtx.fill();
            
            // Draw player direction
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            minimapCtx.strokeStyle = '#00ffff';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(
                camera.position.x * scale + offsetX,
                camera.position.z * scale + offsetY
            );
            minimapCtx.lineTo(
                (camera.position.x + dir.x * 10) * scale + offsetX,
                (camera.position.z + dir.z * 10) * scale + offsetY
            );
            minimapCtx.stroke();
        }

        // ===== LEVEL PROGRESSION =====
        let enemiesKilledThisLevel = 0;
        const ENEMIES_PER_LEVEL = 10;

        function checkLevelProgress() {
            const totalKilled = gameState.correct * 2 + Math.floor(gameState.score / 200);
            const newLevel = Math.floor(totalKilled / ENEMIES_PER_LEVEL) + 1;
            
            if (newLevel > gameState.level && newLevel <= 10) {
                gameState.level = newLevel;
                
                // Show level indicator
                const indicator = document.getElementById('levelIndicator');
                indicator.textContent = `LEVEL ${newLevel}`;
                indicator.classList.add('show');
                setTimeout(() => indicator.classList.remove('show'), 2000);
                
                // Regenerate level
                generateLevel(newLevel);
                
                // Boss every 3 levels
                if (newLevel % 3 === 0) {
                    setTimeout(() => createBoss(), 3000);
                }
                
                // Bonus rewards
                gameState.health = Math.min(gameState.maxHealth, gameState.health + 20);
                gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 10);
            }
        }

        // ===== SHIELD VISUAL =====
        let shieldMesh = null;

        function updateShieldVisual() {
            if (gameState.shieldActive && !shieldMesh) {
                const geom = new THREE.SphereGeometry(2, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: 0x4488ff, 
                    transparent: true, 
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                shieldMesh = new THREE.Mesh(geom, mat);
                scene.add(shieldMesh);
            }
            
            if (shieldMesh) {
                if (gameState.shieldActive) {
                    shieldMesh.position.copy(camera.position);
                    shieldMesh.rotation.y += 0.02;
                    shieldMesh.material.opacity = 0.2 + Math.sin(Date.now() * 0.01) * 0.1;
                } else {
                    scene.remove(shieldMesh);
                    shieldMesh = null;
                }
            }
        }

        // ===== MAIN UPDATE LOOP =====
        function animate() {
            if (gameState.gameOver) return;
            
            requestAnimationFrame(animate);

            // Player movement
            const moveDir = new THREE.Vector3();
            moveDir.x = touchInput.x;
            moveDir.z = touchInput.y;
            moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
            moveDir.y = 0;
            
            if (moveDir.length() > 0.1) {
                const speed = 0.15 * gameState.speedMultiplier;
                camera.position.addScaledVector(moveDir.normalize(), speed);
                
                // Keep in bounds
                camera.position.x = Math.max(-ARENA_SIZE + 3, Math.min(ARENA_SIZE - 3, camera.position.x));
                camera.position.z = Math.max(-ARENA_SIZE + 3, Math.min(ARENA_SIZE - 3, camera.position.z));
            }

            // Camera look
            camera.rotation.order = 'YXZ';
            camera.rotation.y -= touchInput.looking.x;
            camera.rotation.x -= touchInput.looking.y;
            camera.rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, camera.rotation.x));
            
            // Reset look input
            touchInput.looking.x *= 0.8;
            touchInput.looking.y *= 0.8;

            // Update systems
            updateEnemies();
            updatePowerups();
            updateProjectiles();
            updateParticles();
            updateBombs();
            updateTraps();
            updateShieldVisual();
            updateMinimap();
            checkLevelProgress();

            // UI Updates
            document.getElementById('health').textContent = Math.max(0, Math.ceil(gameState.health));
            document.getElementById('healthBar').style.width = (Math.max(0, gameState.health) / gameState.maxHealth * 100) + '%';
            document.getElementById('ammo').textContent = gameState.ammo;
            document.getElementById('ammoBar').style.width = (gameState.ammo / gameState.maxAmmo * 100) + '%';
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('streak').textContent = gameState.streak;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('enemyCount').textContent = enemies.length;
            document.getElementById('correct').textContent = gameState.correct;
            document.getElementById('wrong').textContent = gameState.wrong;

            // Active powerups display
            const powerupsList = document.getElementById('powerupsList');
            powerupsList.innerHTML = gameState.activePowerups.map(p => {
                const remaining = Math.max(0, Math.ceil((p.endTime - Date.now()) / 1000));
                return `<div class="powerup-item">${p.name} (${remaining}s)</div>`;
            }).join('');

            // Game over check
            if (gameState.health <= 0) {
                gameState.gameOver = true;
                document.getElementById('gameOverText').innerHTML = `
                    <div style="font-size: 28px; margin-bottom: 15px;">üíÄ GAME OVER</div>
                    <div>Final Score: <span style="color: #0ff;">${gameState.score}</span></div>
                    <div>Level Reached: <span style="color: #0ff;">${gameState.level}</span></div>
                    <div>Correct Answers: <span style="color: #0f0;">${gameState.correct}</span></div>
                    <div>Wrong Answers: <span style="color: #f44;">${gameState.wrong}</span></div>
                `;
                document.getElementById('gameMessage').style.display = 'block';
                return;
            }

            renderer.render(scene, camera);
        }

        // ===== INITIALIZATION =====
        generateLevel(1);
        for (let i = 0; i < 3; i++) createEnemy();
        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Prevent default touch behaviors
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('#questionModal')) return;
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ESL Jungle Adventure - Grammar Quest</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            position: fixed;
            overflow: hidden;
            touch-action: none;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #1a3a1a;
            color: #fff;
            cursor: none;
        }
        
        #gameContainer {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: none;
        }
        
        /* ===== UI PANELS ===== */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(140, 220, 100, 0.8);
            box-shadow: 0 0 10px rgba(140, 220, 100, 0.6);
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(20, 40, 20, 0.95), rgba(30, 60, 30, 0.9));
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 11px;
            min-width: 160px;
            z-index: 5;
            border: 1px solid rgba(140, 220, 100, 0.4);
            box-shadow: 0 0 20px rgba(100, 200, 100, 0.3);
            pointer-events: none;
        }
        
        .ui-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            gap: 12px;
        }
        
        .ui-label {
            color: #a0d0a0;
            font-weight: bold;
        }
        
        .ui-value {
            color: #dcf0dc;
        }
        
        .bar-container {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 3px;
            border: 1px solid rgba(140, 220, 100, 0.3);
        }
        
        .bar {
            height: 100%;
            transition: width 0.2s ease;
            background: linear-gradient(90deg, #8dc464 0%, #b4dc96 100%);
            box-shadow: 0 0 10px rgba(140, 220, 100, 0.5);
        }
        
        #healthBar {
            background: linear-gradient(90deg, #6c9c4c 0%, #8dc464 100%);
        }
        
        #ammoBar {
            background: linear-gradient(90deg, #c8823c 0%, #dcb864 100%);
        }
        
        #powerupsList {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, rgba(20, 40, 20, 0.95), rgba(30, 60, 30, 0.9));
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 10px;
            z-index: 5;
            min-width: 140px;
            max-width: 200px;
            border: 1px solid rgba(140, 220, 100, 0.4);
            box-shadow: 0 0 20px rgba(100, 200, 100, 0.3);
            pointer-events: none;
        }
        
        .powerup-item {
            color: #dcf0dc;
            margin: 4px 0;
            text-shadow: 0 0 8px rgba(220, 200, 100, 0.6);
        }
        
        /* ===== QUESTION MODAL ===== */
        #questionModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 25, 10, 0.95);
            z-index: 100;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        
        .question-panel {
            background: linear-gradient(135deg, rgba(30, 60, 30, 0.98), rgba(40, 80, 40, 0.95));
            padding: 28px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            border: 3px solid rgba(140, 220, 100, 0.6);
            box-shadow: 0 0 40px rgba(100, 200, 100, 0.4);
        }
        
        .question-header {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #dcf0dc;
            text-shadow: 0 0 15px rgba(220, 200, 100, 0.5);
        }
        
        .question-text {
            font-size: 16px;
            margin-bottom: 20px;
            line-height: 1.5;
            color: #c8e8c8;
            text-align: center;
        }
        
        .answer-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .answer-btn {
            padding: 14px;
            background: linear-gradient(135deg, rgba(80, 160, 80, 0.5), rgba(60, 120, 60, 0.4));
            border: 2px solid rgba(140, 220, 100, 0.5);
            border-radius: 12px;
            color: #dcf0dc;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(100, 200, 100, 0.2);
            text-align: left;
        }
        
        .answer-btn:active {
            transform: scale(0.98);
            background: linear-gradient(135deg, rgba(100, 180, 100, 0.6), rgba(80, 140, 80, 0.5));
        }
        
        .answer-btn.correct {
            background: linear-gradient(135deg, rgba(100, 220, 100, 0.7), rgba(80, 180, 80, 0.6));
            border-color: #8dc464;
            box-shadow: 0 0 25px rgba(140, 220, 100, 0.6);
        }
        
        .answer-btn.wrong {
            background: linear-gradient(135deg, rgba(200, 100, 100, 0.7), rgba(160, 80, 80, 0.6));
            border-color: #c86464;
            box-shadow: 0 0 25px rgba(200, 100, 100, 0.6);
        }
        
        /* ===== SAFE ROOM INDICATOR ===== */
        #safeRoomStatus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(30, 60, 30, 0.95), rgba(40, 80, 40, 0.9));
            padding: 20px 30px;
            border-radius: 16px;
            font-size: 18px;
            font-weight: bold;
            color: #dcf0dc;
            text-align: center;
            display: none;
            z-index: 8;
            border: 2px solid rgba(140, 220, 100, 0.6);
            box-shadow: 0 0 30px rgba(100, 200, 100, 0.5);
            pointer-events: none;
        }
        
        #answerInSafeRoom {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(220, 200, 100, 0.95), rgba(180, 160, 80, 0.9));
            padding: 16px 28px;
            border-radius: 14px;
            font-size: 16px;
            font-weight: bold;
            color: #2a1a0a;
            display: none;
            z-index: 15;
            border: 3px solid #dcb864;
            box-shadow: 0 0 30px rgba(220, 200, 100, 0.6);
            cursor: pointer;
            pointer-events: auto;
        }
        
        #answerInSafeRoom:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 0 40px rgba(220, 200, 100, 0.8);
        }
        
        #gameMessage {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 25, 10, 0.95);
            z-index: 101;
            align-items: center;
            justify-content: center;
        }
        
        #gameOverText {
            background: linear-gradient(135deg, rgba(30, 60, 30, 0.98), rgba(40, 80, 40, 0.95));
            padding: 32px;
            border-radius: 20px;
            font-size: 18px;
            text-align: center;
            color: #dcf0dc;
            border: 3px solid rgba(140, 220, 100, 0.6);
            box-shadow: 0 0 40px rgba(100, 200, 100, 0.4);
        }
        
        #minimap {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 90px;
            height: 90px;
            border: 2px solid rgba(140, 220, 100, 0.5);
            border-radius: 8px;
            z-index: 6;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(100, 200, 100, 0.3);
            background: rgba(20, 40, 20, 0.9);
        }
        
        #minimapCanvas {
            width: 100%;
            height: 100%;
        }
        
        #levelIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            font-size: 48px;
            font-weight: bold;
            color: #dcf0dc;
            text-shadow: 0 0 30px rgba(220, 200, 100, 0.8), 0 0 60px rgba(140, 220, 100, 0.6);
            opacity: 0;
            transition: all 0.5s ease;
            z-index: 50;
            pointer-events: none;
        }
        
        #levelIndicator.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    
    <div id="crosshair"></div>
    
    <!-- UI -->
    <div id="ui">
        <div class="ui-row">
            <span class="ui-label">üåø HEALTH:</span>
            <span class="ui-value"><span id="health">100</span>/100</span>
        </div>
        <div class="bar-container"><div id="healthBar" class="bar" style="width: 100%;"></div></div>
        
        <div class="ui-row" style="margin-top: 10px;">
            <span class="ui-label">üéØ AMMO:</span>
            <span class="ui-value"><span id="ammo">50</span>/50</span>
        </div>
        <div class="bar-container"><div id="ammoBar" class="bar" style="width: 100%;"></div></div>
        
        <div class="ui-row" style="margin-top: 10px;">
            <span class="ui-label">‚≠ê SCORE:</span>
            <span class="ui-value" id="score">0</span>
        </div>
        <div class="ui-row">
            <span class="ui-label">üî• STREAK:</span>
            <span class="ui-value" id="streak">0</span>
        </div>
        <div class="ui-row">
            <span class="ui-label">üìä LEVEL:</span>
            <span class="ui-value" id="level">1</span>
        </div>
        <div class="ui-row">
            <span class="ui-label">üí£ BOMBS:</span>
            <span class="ui-value" id="bombCount">3</span>
        </div>
        <div class="ui-row">
            <span class="ui-label">üëæ ENEMIES:</span>
            <span class="ui-value" id="enemyCount">0</span>
        </div>
        <div class="ui-row">
            <span class="ui-label">‚úÖ CORRECT:</span>
            <span class="ui-value" id="correct">0</span>
        </div>
        <div class="ui-row">
            <span class="ui-label">‚ùå WRONG:</span>
            <span class="ui-value" id="wrong">0</span>
        </div>
    </div>
    
    <div id="powerupsList"></div>
    
    <div id="bossIndicator" style="display: none; position: absolute; top: 120px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, rgba(60, 20, 20, 0.95), rgba(80, 30, 30, 0.9)); padding: 10px 20px; border-radius: 10px; border: 2px solid rgba(255, 100, 100, 0.6); box-shadow: 0 0 25px rgba(255, 100, 100, 0.5); z-index: 20; pointer-events: none; text-align: center; font-weight: bold; color: #ff8888;">
        ‚öîÔ∏è DEFEAT THE BOSS TO PROGRESS ‚öîÔ∏è
    </div>
    
    <div id="controlsOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 25, 10, 0.95); z-index: 200; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px);">
        <div style="background: linear-gradient(135deg, rgba(30, 60, 30, 0.98), rgba(40, 80, 40, 0.95)); padding: 40px; border-radius: 20px; max-width: 600px; border: 3px solid rgba(140, 220, 100, 0.6); box-shadow: 0 0 40px rgba(100, 200, 100, 0.4);">
            <div style="text-align: center; font-size: 28px; font-weight: bold; margin-bottom: 30px; color: #dcf0dc; text-shadow: 0 0 15px rgba(220, 200, 100, 0.5);">
                üå¥ JUNGLE GRAMMAR QUEST üå¥
            </div>
            <div style="font-size: 16px; color: #c8e8c8; line-height: 2; margin-bottom: 25px;">
                <div style="margin-bottom: 15px; font-weight: bold; color: #dcf0dc;">üéÆ Controls:</div>
                <div>üñ±Ô∏è <strong>Mouse</strong> - Look around</div>
                <div>‚å®Ô∏è <strong>WASD / Arrow Keys</strong> - Move</div>
                <div>üî´ <strong>Left Click / Space</strong> - Shoot</div>
                <div>üí£ <strong>B</strong> - Drop Bomb</div>
                <div>‚ùì <strong>Q</strong> - Answer Question</div>
                <div style="margin-top: 20px; font-size: 14px; color: #a0d0a0;">
                    üìö Answer grammar questions correctly to gain ammo, health, and progress through levels!
                </div>
            </div>
            <button id="startGame" style="width: 100%; padding: 16px; background: linear-gradient(135deg, rgba(140, 220, 100, 0.8), rgba(100, 180, 80, 0.7)); border: 3px solid #8dc464; border-radius: 12px; color: #1a3a1a; font-size: 18px; font-weight: bold; cursor: pointer; box-shadow: 0 0 20px rgba(140, 220, 100, 0.5);">
                CLICK TO START
            </button>
        </div>
    </div>
    
    <div id="minimap">
        <canvas id="minimapCanvas"></canvas>
    </div>
    
    <div id="safeRoomStatus">üå≥ SAFE ZONE - No Enemies! üå≥</div>
    <div id="answerInSafeRoom" style="cursor: pointer;">üìù ANSWER QUESTION (Press Q - Bonus Rewards!)</div>
    
    <div id="levelIndicator"></div>
    
    <!-- Question Modal -->
    <div id="questionModal">
        <div class="question-panel">
            <div class="question-header">üå¥ GRAMMAR CHALLENGE üå¥</div>
            <div class="question-text" id="questionText"></div>
            <div class="answer-buttons" id="answerButtons"></div>
        </div>
    </div>
    
    <div id="gameMessage">
        <div id="gameOverText"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ===== QUESTIONS - ADVERBS OF DEGREE & PRESENT PERFECT =====
        const questions = [
            // Adverbs of Degree
            {
                question: "The jungle is ___ beautiful at sunrise.",
                answers: ["very", "too", "much", "more"],
                correct: 0,
                explanation: "'Very' is used to intensify adjectives."
            },
            {
                question: "This tree is ___ tall to climb.",
                answers: ["very", "too", "enough", "quite"],
                correct: 1,
                explanation: "'Too' means excessively, making something impossible or undesirable."
            },
            {
                question: "The vines are strong ___ to hold our weight.",
                answers: ["very", "too", "enough", "quite"],
                correct: 2,
                explanation: "'Enough' comes after adjectives and means sufficient."
            },
            {
                question: "The waterfall is ___ magnificent!",
                answers: ["absolutely", "very", "too", "enough"],
                correct: 0,
                explanation: "'Absolutely' is used with extreme adjectives like magnificent."
            },
            {
                question: "The river flows ___ slowly today.",
                answers: ["very", "quite", "too", "enough"],
                correct: 1,
                explanation: "'Quite' means fairly or moderately."
            },
            {
                question: "The monkeys are ___ playful creatures.",
                answers: ["extremely", "too", "enough", "much"],
                correct: 0,
                explanation: "'Extremely' means to a very great degree."
            },
            {
                question: "It's ___ hot to walk without water.",
                answers: ["very", "too", "enough", "quite"],
                correct: 1,
                explanation: "'Too' indicates something is excessive and causes a problem."
            },
            {
                question: "The path isn't wide ___ for two people.",
                answers: ["very", "too", "enough", "quite"],
                correct: 2,
                explanation: "'Enough' comes after adjectives to show sufficiency."
            },
            {
                question: "The jungle sounds are ___ loud at night.",
                answers: ["fairly", "too", "enough", "much"],
                correct: 0,
                explanation: "'Fairly' means moderately or to a reasonable degree."
            },
            {
                question: "The humidity is ___ unbearable today.",
                answers: ["very", "absolutely", "enough", "quite"],
                correct: 1,
                explanation: "'Absolutely' is used with extreme adjectives like unbearable."
            },
            {
                question: "These flowers are ___ rare in this region.",
                answers: ["rather", "too", "enough", "much"],
                correct: 0,
                explanation: "'Rather' means to a certain extent, somewhat."
            },
            {
                question: "The explorer was ___ exhausted to continue.",
                answers: ["very", "too", "enough", "quite"],
                correct: 1,
                explanation: "'Too' shows excess that prevents an action."
            },
            {
                question: "The bridge is strong ___ to cross safely.",
                answers: ["very", "too", "enough", "quite"],
                correct: 2,
                explanation: "'Enough' after an adjective means sufficient."
            },
            {
                question: "The jungle is ___ dense in this area.",
                answers: ["incredibly", "too", "enough", "much"],
                correct: 0,
                explanation: "'Incredibly' means to an extraordinary degree."
            },
            {
                question: "The rain is falling ___ heavily now.",
                answers: ["pretty", "too", "enough", "much"],
                correct: 0,
                explanation: "'Pretty' (informal) means fairly or quite."
            },

            // Present Perfect
            {
                question: "The explorers ___ discovered a new species.",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "Use 'have' with plural subjects in present perfect."
            },
            {
                question: "She ___ visited this jungle three times.",
                answers: ["have", "has", "had", "having"],
                correct: 1,
                explanation: "Use 'has' with singular third-person subjects (he/she/it)."
            },
            {
                question: "They ___ never seen such tall trees before.",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "'Never' goes between 'have' and the past participle."
            },
            {
                question: "The guide ___ lived in the jungle for years.",
                answers: ["have", "has", "had", "having"],
                correct: 1,
                explanation: "Use 'has' with singular subjects like 'the guide'."
            },
            {
                question: "We ___ already packed our supplies.",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "'Already' goes between 'have' and the past participle."
            },
            {
                question: "Have you ever ___ a jaguar in the wild?",
                answers: ["saw", "seen", "see", "seeing"],
                correct: 1,
                explanation: "Present perfect uses the past participle 'seen', not 'saw'."
            },
            {
                question: "The temperature ___ risen significantly today.",
                answers: ["have", "has", "had", "having"],
                correct: 1,
                explanation: "'Temperature' is singular, so use 'has'."
            },
            {
                question: "I ___ just finished exploring the cave.",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "Use 'have' with 'I', 'you', 'we', 'they'."
            },
            {
                question: "The animals ___ eaten all the fruit.",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "Plural subject 'animals' takes 'have'."
            },
            {
                question: "She ___ forgotten her water bottle.",
                answers: ["have", "has", "had", "having"],
                correct: 1,
                explanation: "Third-person singular 'she' takes 'has'."
            },
            {
                question: "Have they ___ the camp yet?",
                answers: ["reach", "reached", "reaching", "reaches"],
                correct: 1,
                explanation: "Present perfect uses past participle 'reached'."
            },
            {
                question: "The storm ___ passed over the jungle.",
                answers: ["have", "has", "had", "having"],
                correct: 1,
                explanation: "'Storm' is singular, so use 'has'."
            },
            {
                question: "We ___ been hiking since morning.",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "'We' takes 'have' in present perfect."
            },
            {
                question: "Has the river ___ its course?",
                answers: ["change", "changed", "changing", "changes"],
                correct: 1,
                explanation: "Present perfect uses past participle 'changed'."
            },
            {
                question: "The birds ___ flown south for the season.",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "Plural 'birds' takes 'have'."
            },
            {
                question: "He ___ climbed this mountain before.",
                answers: ["have", "has", "had", "having"],
                correct: 1,
                explanation: "Third-person singular 'he' takes 'has'."
            },
            {
                question: "How long ___ you been in the jungle?",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "Questions with 'you' use 'have'."
            },
            {
                question: "The expedition ___ lasted for two weeks.",
                answers: ["have", "has", "had", "having"],
                correct: 1,
                explanation: "'Expedition' is singular, so use 'has'."
            },
            {
                question: "I ___ never heard such strange sounds.",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "'I' takes 'have' in present perfect."
            },
            {
                question: "The rain ___ stopped finally.",
                answers: ["have", "has", "had", "having"],
                correct: 1,
                explanation: "'Rain' (uncountable) is singular, so use 'has'."
            },
            {
                question: "They ___ crossed the river safely.",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "Plural 'they' takes 'have'."
            },
            {
                question: "Has she ___ her way back?",
                answers: ["find", "found", "finding", "finds"],
                correct: 1,
                explanation: "Present perfect uses past participle 'found'."
            },
            {
                question: "The plants ___ grown rapidly this season.",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "Plural 'plants' takes 'have'."
            },
            {
                question: "It ___ been raining all day.",
                answers: ["have", "has", "had", "having"],
                correct: 1,
                explanation: "'It' is third-person singular, so use 'has'."
            },
            {
                question: "We ___ collected many samples today.",
                answers: ["have", "has", "had", "having"],
                correct: 0,
                explanation: "'We' takes 'have' in present perfect."
            }
        ];

        // ===== GAME STATE =====
        const gameState = {
            health: 100,
            maxHealth: 100,
            ammo: 50,
            maxAmmo: 50,
            score: 0,
            level: 1,
            streak: 0,
            correct: 0,
            wrong: 0,
            bombs: 3,
            activePowerups: [],
            inSafeRoom: false,
            godBeamActive: false,
            titanMode: false,
            speedMultiplier: 1,
            damageMultiplier: 1,
            shieldActive: false,
            gameOver: false,
            paused: false,
            regenerating: false,
            fireRateBoost: false,
            lifesteal: false,
            explosiveRounds: false,
            doubleScore: false,
            ghostMode: false,
            luckyMode: false
        };

        const ARENA_SIZE = 80;
        const SAFE_ROOM = { x: 0, z: 60, width: 16, depth: 16 };

        // ===== THREE.JS SETUP =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a3a2a);

        // Add atmospheric particles (fireflies/dust)
        const dustParticles = new THREE.Group();
        for (let i = 0; i < 50; i++) {
            const particle = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 6, 6),
                new THREE.MeshBasicMaterial({ 
                    color: 0xccee88,
                    transparent: true,
                    opacity: 0.6
                })
            );
            particle.position.set(
                (Math.random() - 0.5) * 150,
                Math.random() * 20 + 2,
                (Math.random() - 0.5) * 150
            );
            particle.userData = {
                speedX: (Math.random() - 0.5) * 0.02,
                speedY: (Math.random() - 0.5) * 0.02,
                speedZ: (Math.random() - 0.5) * 0.02
            };
            dustParticles.add(particle);
        }
        scene.add(dustParticles);
        
        // Animate dust particles
        function updateDustParticles() {
            dustParticles.children.forEach(particle => {
                particle.position.x += particle.userData.speedX;
                particle.position.y += particle.userData.speedY;
                particle.position.z += particle.userData.speedZ;
                
                particle.material.opacity = 0.3 + Math.sin(Date.now() * 0.001 + particle.position.x) * 0.3;
                
                if (Math.abs(particle.position.x) > 75) particle.position.x *= -0.9;
                if (particle.position.y < 2 || particle.position.y > 22) particle.userData.speedY *= -1;
                if (Math.abs(particle.position.z) > 75) particle.position.z *= -0.9;
            });
        }

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0);

        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true, 
            powerPreference: 'high-performance',
            stencil: false,
            depth: true,
            logarithmicDepthBuffer: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.4;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.physicallyCorrectLights = true;
        document.getElementById('gameContainer').appendChild(renderer.domElement);

        // ===== LIGHTING =====
        const ambientLight = new THREE.AmbientLight(0x6a8a5a, 0.6);
        scene.add(ambientLight);
        
        // Hemisphere light for more natural ambient lighting
        const hemiLight = new THREE.HemisphereLight(0x9dddff, 0x4a6a3a, 0.7);
        hemiLight.position.set(0, 50, 0);
        scene.add(hemiLight);

        const sunLight = new THREE.DirectionalLight(0xfff8e1, 1.6);
        sunLight.position.set(60, 120, 60);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096;
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 300;
        sunLight.shadow.camera.left = -140;
        sunLight.shadow.camera.right = 140;
        sunLight.shadow.camera.top = 140;
        sunLight.shadow.camera.bottom = -140;
        sunLight.shadow.bias = -0.0003;
        sunLight.shadow.radius = 3;
        sunLight.shadow.normalBias = 0.02;
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0x88c8dc, 0.5);
        fillLight.position.set(-50, 60, -50);
        fillLight.castShadow = true;
        fillLight.shadow.mapSize.width = 2048;
        fillLight.shadow.mapSize.height = 2048;
        scene.add(fillLight);

        const moonLight = new THREE.PointLight(0xb8dcff, 0.9, 150);
        moonLight.position.set(-40, 50, -40);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width = 2048;
        moonLight.shadow.mapSize.height = 2048;
        moonLight.decay = 2;
        scene.add(moonLight);
        
        // Add rim light for better depth perception
        const rimLight = new THREE.DirectionalLight(0xaaddff, 0.4);
        rimLight.position.set(0, 30, -80);
        scene.add(rimLight);

        // Atmospheric fog with better color and density
        scene.fog = new THREE.FogExp2(0x2a4a3a, 0.0065);

        // ===== ARENA =====
        function generateLevel(level) {
            // Floor - detailed jungle ground with variation
            const floorGeometry = new THREE.PlaneGeometry(ARENA_SIZE * 2, ARENA_SIZE * 2, 40, 40);
            const vertices = floorGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.1) * Math.cos(vertices[i + 1] * 0.1) * 0.5;
            }
            floorGeometry.computeVertexNormals();
            
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a5a2a, 
                roughness: 0.95,
                metalness: 0.05,
                flatShading: false
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Add ground vegetation patches
            for (let i = 0; i < 50; i++) {
                const grassPatch = new THREE.Mesh(
                    new THREE.CircleGeometry(2 + Math.random() * 3, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x4a6a3a,
                        roughness: 0.9,
                        metalness: 0.1
                    })
                );
                grassPatch.rotation.x = -Math.PI / 2;
                grassPatch.position.set(
                    (Math.random() - 0.5) * ARENA_SIZE * 1.8,
                    0.02,
                    (Math.random() - 0.5) * ARENA_SIZE * 1.8
                );
                grassPatch.receiveShadow = true;
                scene.add(grassPatch);
            }

            // Walls - textured tree line with depth
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a4a1a,
                roughness: 0.85,
                metalness: 0.1
            });
            [-ARENA_SIZE, ARENA_SIZE].forEach(x => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(1, 12, ARENA_SIZE * 2), wallMaterial);
                wall.position.set(x, 6, 0);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                
                // Add foliage detail to walls
                for (let z = -ARENA_SIZE; z < ARENA_SIZE; z += 8) {
                    const foliage = new THREE.Mesh(
                        new THREE.SphereGeometry(2, 8, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x3a5a2a,
                            roughness: 0.9
                        })
                    );
                    foliage.position.set(x, 4 + Math.random() * 6, z);
                    foliage.castShadow = true;
                    scene.add(foliage);
                }
            });
            [-ARENA_SIZE, ARENA_SIZE].forEach(z => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(ARENA_SIZE * 2, 12, 1), wallMaterial);
                wall.position.set(0, 6, z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                
                // Add foliage detail to walls
                for (let x = -ARENA_SIZE; x < ARENA_SIZE; x += 8) {
                    const foliage = new THREE.Mesh(
                        new THREE.SphereGeometry(2, 8, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x3a5a2a,
                            roughness: 0.9
                        })
                    );
                    foliage.position.set(x, 4 + Math.random() * 6, z);
                    foliage.castShadow = true;
                    scene.add(foliage);
                }
            });

            // Safe room - enhanced clearing with better visuals
            const safeRoomFloor = new THREE.Mesh(
                new THREE.BoxGeometry(SAFE_ROOM.width, 0.3, SAFE_ROOM.depth),
                new THREE.MeshStandardMaterial({ 
                    color: 0x5a7a4a,
                    roughness: 0.7,
                    metalness: 0.2,
                    emissive: 0x4a6a3a,
                    emissiveIntensity: 0.1
                })
            );
            safeRoomFloor.position.set(SAFE_ROOM.x, 0.15, SAFE_ROOM.z);
            safeRoomFloor.receiveShadow = true;
            scene.add(safeRoomFloor);

            // Safe room markers - glowing leaf pillars
            const markerGeometry = new THREE.CylinderGeometry(0.4, 0.4, 8, 12);
            const markerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8dc464, 
                emissive: 0x6aa050, 
                emissiveIntensity: 0.8,
                roughness: 0.4,
                metalness: 0.3
            });
            [
                [-SAFE_ROOM.width/2, SAFE_ROOM.depth/2],
                [SAFE_ROOM.width/2, SAFE_ROOM.depth/2],
                [-SAFE_ROOM.width/2, -SAFE_ROOM.depth/2],
                [SAFE_ROOM.width/2, -SAFE_ROOM.depth/2]
            ].forEach(([dx, dz]) => {
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(SAFE_ROOM.x + dx, 4, SAFE_ROOM.z + dz);
                marker.castShadow = true;
                scene.add(marker);
                
                // Add leaf decoration on top
                const leaf = new THREE.Mesh(
                    new THREE.SphereGeometry(0.8, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8dc464,
                        emissive: 0x6aa050,
                        emissiveIntensity: 0.6
                    })
                );
                leaf.position.set(SAFE_ROOM.x + dx, 8.5, SAFE_ROOM.z + dz);
                leaf.castShadow = true;
                scene.add(leaf);
                
                // Add point light for glow
                const light = new THREE.PointLight(0x8dc464, 0.5, 15);
                light.position.set(SAFE_ROOM.x + dx, 5, SAFE_ROOM.z + dz);
                scene.add(light);
            });

            // Obstacles - detailed trees with trunks and canopies
            const obstacleTypes = [
                { trunkColor: 0x3a2a1a, canopyColor: 0x4a6a3a, height: 8, radius: 1.5 },
                { trunkColor: 0x4a3a2a, canopyColor: 0x5a7a4a, height: 10, radius: 1.8 },
                { trunkColor: 0x2a1a0a, canopyColor: 0x3a5a2a, height: 12, radius: 2 }
            ];
            
            for (let i = 0; i < 15 + level * 2; i++) {
                const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                let x, z;
                do {
                    x = (Math.random() - 0.5) * ARENA_SIZE * 1.8;
                    z = (Math.random() - 0.5) * ARENA_SIZE * 1.8;
                } while (
                    Math.abs(x - SAFE_ROOM.x) < SAFE_ROOM.width && 
                    Math.abs(z - SAFE_ROOM.z) < SAFE_ROOM.depth
                );
                
                // Tree trunk
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.6, 0.8, type.height, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: type.trunkColor,
                        roughness: 0.95,
                        metalness: 0.1
                    })
                );
                trunk.position.set(x, type.height / 2, z);
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);
                
                // Tree canopy
                const canopy = new THREE.Mesh(
                    new THREE.SphereGeometry(type.radius, 12, 12),
                    new THREE.MeshStandardMaterial({ 
                        color: type.canopyColor,
                        roughness: 0.85,
                        metalness: 0.05
                    })
                );
                canopy.position.set(x, type.height + type.radius - 0.5, z);
                canopy.castShadow = true;
                canopy.receiveShadow = true;
                scene.add(canopy);
                
                // Additional foliage layers
                if (Math.random() > 0.5) {
                    const extraFoliage = new THREE.Mesh(
                        new THREE.SphereGeometry(type.radius * 0.7, 10, 10),
                        new THREE.MeshStandardMaterial({ 
                            color: type.canopyColor,
                            roughness: 0.9
                        })
                    );
                    extraFoliage.position.set(
                        x + (Math.random() - 0.5) * 1.5, 
                        type.height + type.radius - 1.5, 
                        z + (Math.random() - 0.5) * 1.5
                    );
                    extraFoliage.castShadow = true;
                    scene.add(extraFoliage);
                }
            }
            
            // Add ambient flora
            for (let i = 0; i < 30; i++) {
                const bush = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x3a5a2a,
                        roughness: 0.9
                    })
                );
                bush.position.set(
                    (Math.random() - 0.5) * ARENA_SIZE * 1.8,
                    0.3,
                    (Math.random() - 0.5) * ARENA_SIZE * 1.8
                );
                bush.castShadow = true;
                bush.receiveShadow = true;
                scene.add(bush);
            }
        }

        // ===== ENEMIES =====
        const enemies = [];
        const bosses = [];
        const ENEMY_TYPES = [
            { name: 'Spider', color: 0xff4444, size: 1.2, speed: 0.04, health: 15, damage: 8, kamikaze: false, glow: 0.5 },
            { name: 'Snake', color: 0x44ff44, size: 1.5, speed: 0.07, health: 12, damage: 12, kamikaze: false, glow: 0.6 },
            { name: 'Scorpion', color: 0xffaa44, size: 1.3, speed: 0.1, health: 10, damage: 20, kamikaze: true, glow: 0.7 },
            { name: 'Panther', color: 0xaa44ff, size: 1.6, speed: 0.12, health: 25, damage: 15, kamikaze: false, glow: 0.6 },
            { name: 'Crocodile', color: 0x44aaff, size: 2, speed: 0.05, health: 35, damage: 18, kamikaze: false, glow: 0.5 },
            { name: 'Wasp', color: 0xffff44, size: 0.8, speed: 0.15, health: 8, damage: 10, kamikaze: true, glow: 0.8 },
            { name: 'Gorilla', color: 0xff8844, size: 2.2, speed: 0.06, health: 40, damage: 25, kamikaze: false, glow: 0.5 },
            { name: 'Viper', color: 0xff44ff, size: 1.4, speed: 0.09, health: 18, damage: 22, kamikaze: false, glow: 0.7 }
        ];

        const BOSS_TYPES = [
            { 
                name: 'ü¶ç KING KONG', 
                color: 0xff8800, 
                size: 8, 
                speed: 0.08, 
                health: 500, 
                damage: 35,
                attackPattern: 'charge',
                spawnMinions: true,
                minionType: 'Gorilla'
            },
            { 
                name: 'üêç ANACONDA QUEEN', 
                color: 0x00ff88, 
                size: 12, 
                speed: 0.06, 
                health: 600, 
                damage: 40,
                attackPattern: 'circle',
                spawnMinions: true,
                minionType: 'Snake'
            },
            { 
                name: 'ü¶Ç SCORPION EMPEROR', 
                color: 0xff0088, 
                size: 10, 
                speed: 0.1, 
                health: 550, 
                damage: 50,
                attackPattern: 'teleport',
                spawnMinions: true,
                minionType: 'Scorpion'
            }
        ];

        function createEnemy(bossType = null) {
            if (bossType) {
                // Create boss with highly detailed model
                const type = bossType;
                
                // Boss body - complex multi-mesh structure
                const bodyGroup = new THREE.Group();
                
                // Main body with higher detail
                const mainBody = new THREE.Mesh(
                    new THREE.SphereGeometry(type.size * 0.5, 32, 32),
                    new THREE.MeshStandardMaterial({ 
                        color: type.color,
                        emissive: type.color,
                        emissiveIntensity: 0.7,
                        metalness: 0.5,
                        roughness: 0.5
                    })
                );
                bodyGroup.add(mainBody);
                
                // Add layered armor plates
                for (let layer = 0; layer < 3; layer++) {
                    const armorRing = new THREE.Mesh(
                        new THREE.TorusGeometry(type.size * (0.4 + layer * 0.15), type.size * 0.08, 16, 32),
                        new THREE.MeshStandardMaterial({ 
                            color: new THREE.Color(type.color).multiplyScalar(0.7 + layer * 0.1),
                            emissive: type.color,
                            emissiveIntensity: 0.8,
                            metalness: 0.7,
                            roughness: 0.3
                        })
                    );
                    armorRing.rotation.x = Math.PI / 2;
                    armorRing.position.y = (layer - 1) * type.size * 0.25;
                    bodyGroup.add(armorRing);
                }
                
                // Add large spiky protrusions
                for (let i = 0; i < 12; i++) {
                    const spike = new THREE.Mesh(
                        new THREE.ConeGeometry(type.size * 0.2, type.size * 0.6, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: type.color,
                            emissive: type.color,
                            emissiveIntensity: 0.9,
                            metalness: 0.6,
                            roughness: 0.4
                        })
                    );
                    const angle = (i / 12) * Math.PI * 2;
                    const elevation = Math.sin(i * 0.5) * 0.5;
                    spike.position.set(
                        Math.cos(angle) * type.size * 0.6,
                        elevation * type.size * 0.4,
                        Math.sin(angle) * type.size * 0.6
                    );
                    const lookAt = new THREE.Vector3(
                        Math.cos(angle) * type.size * 1.5,
                        elevation * type.size * 0.8,
                        Math.sin(angle) * type.size * 1.5
                    );
                    spike.lookAt(lookAt);
                    spike.rotateX(-Math.PI / 2);
                    bodyGroup.add(spike);
                }
                
                // Boss eyes with glow
                const eyeGeometry = new THREE.SphereGeometry(type.size * 0.15, 16, 16);
                const eyeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 2,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-type.size * 0.25, type.size * 0.25, type.size * 0.45);
                bodyGroup.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(type.size * 0.25, type.size * 0.25, type.size * 0.45);
                bodyGroup.add(rightEye);
                
                // Add eye glow lights
                const leftEyeLight = new THREE.PointLight(0xff0000, 0.8, type.size * 2);
                leftEyeLight.position.copy(leftEye.position);
                bodyGroup.add(leftEyeLight);
                
                const rightEyeLight = new THREE.PointLight(0xff0000, 0.8, type.size * 2);
                rightEyeLight.position.copy(rightEye.position);
                bodyGroup.add(rightEyeLight);
                
                // Add pulsing energy core
                const core = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(type.size * 0.25, 1),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffffff,
                        emissive: type.color,
                        emissiveIntensity: 1.5,
                        transparent: true,
                        opacity: 0.8,
                        metalness: 0.9,
                        roughness: 0.1
                    })
                );
                bodyGroup.add(core);
                
                let x, z;
                do {
                    x = (Math.random() - 0.5) * ARENA_SIZE * 1.2;
                    z = (Math.random() - 0.5) * ARENA_SIZE * 1.2;
                } while (Math.sqrt(x*x + z*z) < 30);
                
                bodyGroup.position.set(x, type.size * 0.6, z);
                bodyGroup.castShadow = true;
                scene.add(bodyGroup);
                
                // Boss main point light
                const bossLight = new THREE.PointLight(type.color, 2, type.size * 4);
                bossLight.position.copy(bodyGroup.position);
                scene.add(bossLight);
                
                // Add particle aura around boss
                const auraParticles = [];
                for (let i = 0; i < 20; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(type.size * 0.08, 8, 8),
                        new THREE.MeshBasicMaterial({ 
                            color: type.color,
                            transparent: true,
                            opacity: 0.6
                        })
                    );
                    particle.position.copy(bodyGroup.position);
                    particle.userData.angle = (i / 20) * Math.PI * 2;
                    particle.userData.radius = type.size * 1.2;
                    particle.userData.speed = 0.02 + Math.random() * 0.02;
                    particle.userData.height = (Math.random() - 0.5) * type.size;
                    scene.add(particle);
                    auraParticles.push(particle);
                }

                // Boss health bar
                const healthBarContainer = document.createElement('div');
                healthBarContainer.style.cssText = `
                    position: absolute;
                    top: 70px;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 400px;
                    background: rgba(20, 40, 20, 0.95);
                    padding: 12px 16px;
                    border-radius: 12px;
                    border: 2px solid rgba(255, 100, 100, 0.6);
                    box-shadow: 0 0 30px rgba(255, 100, 100, 0.5);
                    z-index: 20;
                `;
                healthBarContainer.innerHTML = `
                    <div style="text-align: center; font-weight: bold; margin-bottom: 6px; font-size: 16px; color: #ff8888;">${type.name}</div>
                    <div style="width: 100%; height: 12px; background: rgba(0, 0, 0, 0.7); border-radius: 6px; overflow: hidden; border: 1px solid rgba(255, 100, 100, 0.4);">
                        <div class="boss-health-bar" style="height: 100%; width: 100%; background: linear-gradient(90deg, #ff4444 0%, #ff8888 100%); transition: width 0.3s;"></div>
                    </div>
                `;
                document.body.appendChild(healthBarContainer);
                
                const boss = {
                    mesh: bodyGroup,
                    position: bodyGroup.position,
                    health: type.health,
                    maxHealth: type.health,
                    enemyType: type,
                    isBoss: true,
                    healthBarElement: healthBarContainer,
                    healthBarFill: healthBarContainer.querySelector('.boss-health-bar'),
                    attackTimer: 0,
                    teleportTimer: 0,
                    minionTimer: 0,
                    light: bossLight,
                    core: core,
                    leftEye: leftEye,
                    rightEye: rightEye,
                    auraParticles: auraParticles
                };
                
                bosses.push(boss);
                enemies.push(boss);
                return boss;
            } else {
                // Create highly detailed regular enemies
                const type = ENEMY_TYPES[Math.floor(Math.random() * Math.min(ENEMY_TYPES.length, 3 + gameState.level))];
                
                const enemyGroup = new THREE.Group();
                let mainMesh, eyeLeft, eyeRight;
                
                switch(type.name) {
                    case 'Spider':
                        // Main body
                        mainMesh = new THREE.Mesh(
                            new THREE.SphereGeometry(type.size * 0.5, 16, 16),
                            new THREE.MeshStandardMaterial({ 
                                color: type.color,
                                emissive: type.color,
                                emissiveIntensity: type.glow,
                                metalness: 0.4,
                                roughness: 0.7
                            })
                        );
                        enemyGroup.add(mainMesh);
                        
                        // Spider legs
                        for (let i = 0; i < 8; i++) {
                            const leg = new THREE.Group();
                            const segment1 = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.08, 0.08, type.size * 0.8, 8),
                                new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.5, roughness: 0.5 })
                            );
                            segment1.rotation.z = Math.PI / 4;
                            segment1.position.x = type.size * 0.4;
                            leg.add(segment1);
                            
                            const segment2 = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.06, 0.06, type.size * 0.6, 8),
                                new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.5, roughness: 0.5 })
                            );
                            segment2.rotation.z = -Math.PI / 3;
                            segment2.position.set(type.size * 0.7, -type.size * 0.3, 0);
                            leg.add(segment2);
                            
                            const angle = (i / 8) * Math.PI * 2;
                            leg.rotation.y = angle;
                            leg.position.y = type.size * 0.1;
                            leg.castShadow = true;
                            enemyGroup.add(leg);
                        }
                        
                        // Multiple eyes
                        for (let i = 0; i < 4; i++) {
                            const eye = new THREE.Mesh(
                                new THREE.SphereGeometry(0.08, 8, 8),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xff0000,
                                    emissive: 0xff0000,
                                    emissiveIntensity: 1.5
                                })
                            );
                            eye.position.set((i % 2) * 0.15 - 0.075, type.size * 0.3 + Math.floor(i / 2) * 0.1, type.size * 0.45);
                            enemyGroup.add(eye);
                        }
                        break;
                        
                    case 'Snake':
                        // Segmented body
                        for (let i = 0; i < 5; i++) {
                            const segment = new THREE.Mesh(
                                new THREE.SphereGeometry(type.size * 0.5 * (1 - i * 0.1), 12, 12),
                                new THREE.MeshStandardMaterial({ 
                                    color: new THREE.Color(type.color).multiplyScalar(0.8 + i * 0.05),
                                    emissive: type.color,
                                    emissiveIntensity: type.glow * (1 - i * 0.15),
                                    metalness: 0.3,
                                    roughness: 0.6
                                })
                            );
                            segment.position.z = -i * type.size * 0.4;
                            segment.castShadow = true;
                            enemyGroup.add(segment);
                            if (i === 0) mainMesh = segment;
                        }
                        
                        // Snake head details
                        const head = new THREE.Mesh(
                            new THREE.ConeGeometry(type.size * 0.3, type.size * 0.4, 8),
                            new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.4, roughness: 0.6 })
                        );
                        head.rotation.x = Math.PI / 2;
                        head.position.z = type.size * 0.3;
                        enemyGroup.add(head);
                        
                        // Glowing eyes
                        eyeLeft = new THREE.Mesh(
                            new THREE.SphereGeometry(0.1, 8, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 2
                            })
                        );
                        eyeLeft.position.set(-0.15, type.size * 0.3, type.size * 0.4);
                        enemyGroup.add(eyeLeft);
                        
                        eyeRight = new THREE.Mesh(
                            new THREE.SphereGeometry(0.1, 8, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 2
                            })
                        );
                        eyeRight.position.set(0.15, type.size * 0.3, type.size * 0.4);
                        enemyGroup.add(eyeRight);
                        break;
                        
                    case 'Scorpion':
                        // Body
                        mainMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(type.size * 0.8, type.size * 0.4, type.size),
                            new THREE.MeshStandardMaterial({ 
                                color: type.color,
                                emissive: type.color,
                                emissiveIntensity: type.glow,
                                metalness: 0.6,
                                roughness: 0.4
                            })
                        );
                        enemyGroup.add(mainMesh);
                        
                        // Pincers
                        for (let side = -1; side <= 1; side += 2) {
                            const pincer = new THREE.Group();
                            const base = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.1, 0.12, type.size * 0.5, 8),
                                new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.7, roughness: 0.3 })
                            );
                            base.rotation.z = side * Math.PI / 4;
                            pincer.add(base);
                            
                            const claw1 = new THREE.Mesh(
                                new THREE.BoxGeometry(0.15, 0.3, 0.08),
                                new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.7, roughness: 0.3 })
                            );
                            claw1.position.set(0, type.size * 0.3, 0.1);
                            pincer.add(claw1);
                            
                            const claw2 = new THREE.Mesh(
                                new THREE.BoxGeometry(0.15, 0.3, 0.08),
                                new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.7, roughness: 0.3 })
                            );
                            claw2.position.set(0, type.size * 0.3, -0.1);
                            pincer.add(claw2);
                            
                            pincer.position.set(side * type.size * 0.5, 0, type.size * 0.3);
                            pincer.castShadow = true;
                            enemyGroup.add(pincer);
                        }
                        
                        // Tail with stinger
                        const tailSegments = 4;
                        for (let i = 0; i < tailSegments; i++) {
                            const segment = new THREE.Mesh(
                                new THREE.SphereGeometry(type.size * 0.15 * (1 - i * 0.15), 8, 8),
                                new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.5, roughness: 0.5 })
                            );
                            segment.position.set(0, type.size * 0.3 * (i + 1), -type.size * 0.3 * i);
                            segment.castShadow = true;
                            enemyGroup.add(segment);
                        }
                        
                        // Stinger
                        const stinger = new THREE.Mesh(
                            new THREE.ConeGeometry(type.size * 0.15, type.size * 0.4, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: 0x8800ff,
                                emissive: 0x8800ff,
                                emissiveIntensity: 1,
                                metalness: 0.9,
                                roughness: 0.1
                            })
                        );
                        stinger.position.set(0, type.size * 1.4, -type.size * 1.2);
                        stinger.rotation.x = -Math.PI / 4;
                        enemyGroup.add(stinger);
                        break;
                        
                    case 'Panther':
                        // Body - using cylinder and spheres instead of capsule
                        const pantherBody = new THREE.Mesh(
                            new THREE.CylinderGeometry(type.size * 0.4, type.size * 0.4, type.size * 0.8, 16),
                            new THREE.MeshStandardMaterial({ 
                                color: type.color,
                                emissive: type.color,
                                emissiveIntensity: type.glow,
                                metalness: 0.3,
                                roughness: 0.8
                            })
                        );
                        pantherBody.rotation.z = Math.PI / 2;
                        enemyGroup.add(pantherBody);
                        mainMesh = pantherBody;
                        
                        // Rounded ends for body
                        const frontSphere = new THREE.Mesh(
                            new THREE.SphereGeometry(type.size * 0.4, 16, 16),
                            new THREE.MeshStandardMaterial({ 
                                color: type.color,
                                emissive: type.color,
                                emissiveIntensity: type.glow,
                                metalness: 0.3,
                                roughness: 0.8
                            })
                        );
                        frontSphere.position.set(type.size * 0.4, 0, 0);
                        enemyGroup.add(frontSphere);
                        
                        const backSphere = new THREE.Mesh(
                            new THREE.SphereGeometry(type.size * 0.4, 16, 16),
                            new THREE.MeshStandardMaterial({ 
                                color: type.color,
                                emissive: type.color,
                                emissiveIntensity: type.glow,
                                metalness: 0.3,
                                roughness: 0.8
                            })
                        );
                        backSphere.position.set(-type.size * 0.4, 0, 0);
                        enemyGroup.add(backSphere);
                        
                        // Head
                        const pantherHead = new THREE.Mesh(
                            new THREE.SphereGeometry(type.size * 0.35, 16, 16),
                            new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.3, roughness: 0.8 })
                        );
                        pantherHead.position.set(type.size * 0.6, 0, 0);
                        enemyGroup.add(pantherHead);
                        
                        // Ears
                        for (let side = -1; side <= 1; side += 2) {
                            const ear = new THREE.Mesh(
                                new THREE.ConeGeometry(0.15, 0.3, 8),
                                new THREE.MeshStandardMaterial({ color: type.color })
                            );
                            ear.position.set(type.size * 0.6, type.size * 0.3, side * 0.2);
                            enemyGroup.add(ear);
                        }
                        
                        // Glowing eyes
                        eyeLeft = new THREE.Mesh(
                            new THREE.SphereGeometry(0.12, 8, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: 0xff00ff,
                                emissive: 0xff00ff,
                                emissiveIntensity: 2
                            })
                        );
                        eyeLeft.position.set(type.size * 0.75, type.size * 0.1, -0.15);
                        enemyGroup.add(eyeLeft);
                        
                        eyeRight = eyeLeft.clone();
                        eyeRight.position.z = 0.15;
                        enemyGroup.add(eyeRight);
                        
                        // Legs
                        for (let i = 0; i < 4; i++) {
                            const leg = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.08, 0.1, type.size * 0.6, 8),
                                new THREE.MeshStandardMaterial({ color: type.color })
                            );
                            leg.position.set((i < 2 ? 0.3 : -0.3), -type.size * 0.5, (i % 2 === 0 ? -0.3 : 0.3));
                            leg.castShadow = true;
                            enemyGroup.add(leg);
                        }
                        break;
                        
                    case 'Crocodile':
                        // Body segments
                        for (let i = 0; i < 4; i++) {
                            const segment = new THREE.Mesh(
                                new THREE.BoxGeometry(
                                    type.size * (0.8 - i * 0.1), 
                                    type.size * 0.4, 
                                    type.size * 0.5
                                ),
                                new THREE.MeshStandardMaterial({ 
                                    color: new THREE.Color(type.color).multiplyScalar(0.9 + i * 0.025),
                                    emissive: type.color,
                                    emissiveIntensity: type.glow,
                                    metalness: 0.4,
                                    roughness: 0.8
                                })
                            );
                            segment.position.x = -i * type.size * 0.4;
                            segment.castShadow = true;
                            enemyGroup.add(segment);
                            if (i === 0) mainMesh = segment;
                        }
                        
                        // Head/snout
                        const snout = new THREE.Mesh(
                            new THREE.ConeGeometry(type.size * 0.3, type.size * 0.6, 8),
                            new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.3, roughness: 0.7 })
                        );
                        snout.rotation.z = -Math.PI / 2;
                        snout.position.x = type.size * 0.6;
                        enemyGroup.add(snout);
                        
                        // Spikes on back
                        for (let i = 0; i < 6; i++) {
                            const spike = new THREE.Mesh(
                                new THREE.ConeGeometry(0.1, 0.3, 6),
                                new THREE.MeshStandardMaterial({ 
                                    color: type.color,
                                    emissive: type.color,
                                    emissiveIntensity: 0.8
                                })
                            );
                            spike.position.set(-i * type.size * 0.25, type.size * 0.3, 0);
                            enemyGroup.add(spike);
                        }
                        
                        // Eyes
                        for (let side = -1; side <= 1; side += 2) {
                            const eye = new THREE.Mesh(
                                new THREE.SphereGeometry(0.12, 8, 8),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xffaa00,
                                    emissive: 0xffaa00,
                                    emissiveIntensity: 1.5
                                })
                            );
                            eye.position.set(type.size * 0.5, type.size * 0.25, side * 0.2);
                            enemyGroup.add(eye);
                        }
                        break;
                        
                    case 'Wasp':
                        // Body segments
                        mainMesh = new THREE.Mesh(
                            new THREE.SphereGeometry(type.size * 0.6, 12, 12),
                            new THREE.MeshStandardMaterial({ 
                                color: type.color,
                                emissive: type.color,
                                emissiveIntensity: type.glow,
                                metalness: 0.5,
                                roughness: 0.5
                            })
                        );
                        enemyGroup.add(mainMesh);
                        
                        const abdomen = new THREE.Mesh(
                            new THREE.SphereGeometry(type.size * 0.5, 12, 12),
                            new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.6, roughness: 0.4 })
                        );
                        abdomen.position.z = -type.size * 0.8;
                        enemyGroup.add(abdomen);
                        
                        // Stripes
                        for (let i = 0; i < 3; i++) {
                            const stripe = new THREE.Mesh(
                                new THREE.TorusGeometry(type.size * 0.45, 0.08, 8, 16),
                                new THREE.MeshStandardMaterial({ color: type.color, emissive: type.color, emissiveIntensity: 0.8 })
                            );
                            stripe.rotation.y = Math.PI / 2;
                            stripe.position.z = -type.size * (0.3 + i * 0.25);
                            enemyGroup.add(stripe);
                        }
                        
                        // Wings
                        for (let side = -1; side <= 1; side += 2) {
                            const wing = new THREE.Mesh(
                                new THREE.PlaneGeometry(type.size * 0.8, type.size * 1.2),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xaaddff,
                                    transparent: true,
                                    opacity: 0.4,
                                    side: THREE.DoubleSide,
                                    metalness: 0.8,
                                    roughness: 0.2
                                })
                            );
                            wing.position.set(0, type.size * 0.3, side * type.size * 0.4);
                            wing.rotation.y = side * Math.PI / 6;
                            wing.rotation.x = Math.PI / 6;
                            enemyGroup.add(wing);
                        }
                        
                        // Stinger
                        const waspStinger = new THREE.Mesh(
                            new THREE.ConeGeometry(0.08, type.size * 0.4, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 1.5,
                                metalness: 0.9,
                                roughness: 0.1
                            })
                        );
                        waspStinger.rotation.x = Math.PI / 2;
                        waspStinger.position.z = -type.size * 1.2;
                        enemyGroup.add(waspStinger);
                        break;
                        
                    case 'Gorilla':
                        // Torso
                        mainMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(type.size * 0.8, type.size, type.size * 0.6),
                            new THREE.MeshStandardMaterial({ 
                                color: type.color,
                                emissive: type.color,
                                emissiveIntensity: type.glow,
                                metalness: 0.2,
                                roughness: 0.9
                            })
                        );
                        enemyGroup.add(mainMesh);
                        
                        // Head
                        const gorillaHead = new THREE.Mesh(
                            new THREE.BoxGeometry(type.size * 0.6, type.size * 0.6, type.size * 0.5),
                            new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.2, roughness: 0.9 })
                        );
                        gorillaHead.position.y = type.size * 0.7;
                        enemyGroup.add(gorillaHead);
                        
                        // Arms
                        for (let side = -1; side <= 1; side += 2) {
                            const arm = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.15, 0.2, type.size * 1.2, 8),
                                new THREE.MeshStandardMaterial({ color: type.color })
                            );
                            arm.position.set(side * type.size * 0.5, -type.size * 0.3, 0);
                            arm.rotation.z = side * Math.PI / 6;
                            arm.castShadow = true;
                            enemyGroup.add(arm);
                            
                            // Hands
                            const hand = new THREE.Mesh(
                                new THREE.SphereGeometry(0.25, 12, 12),
                                new THREE.MeshStandardMaterial({ color: type.color })
                            );
                            hand.position.set(side * type.size * 0.7, -type.size * 0.9, 0);
                            enemyGroup.add(hand);
                        }
                        
                        // Glowing red eyes
                        eyeLeft = new THREE.Mesh(
                            new THREE.SphereGeometry(0.1, 8, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 2
                            })
                        );
                        eyeLeft.position.set(-0.15, type.size * 0.75, type.size * 0.25);
                        enemyGroup.add(eyeLeft);
                        
                        eyeRight = eyeLeft.clone();
                        eyeRight.position.x = 0.15;
                        enemyGroup.add(eyeRight);
                        break;
                        
                    case 'Viper':
                        // Coiled body
                        for (let i = 0; i < 6; i++) {
                            const coil = new THREE.Mesh(
                                new THREE.TorusGeometry(type.size * (0.6 - i * 0.08), type.size * 0.15, 12, 24),
                                new THREE.MeshStandardMaterial({ 
                                    color: new THREE.Color(type.color).multiplyScalar(0.8 + i * 0.04),
                                    emissive: type.color,
                                    emissiveIntensity: type.glow,
                                    metalness: 0.4,
                                    roughness: 0.6
                                })
                            );
                            coil.rotation.x = Math.PI / 2;
                            coil.position.y = i * type.size * 0.15;
                            coil.castShadow = true;
                            enemyGroup.add(coil);
                            if (i === 0) mainMesh = coil;
                        }
                        
                        // Head emerging from top
                        const viperHead = new THREE.Mesh(
                            new THREE.ConeGeometry(type.size * 0.25, type.size * 0.5, 8),
                            new THREE.MeshStandardMaterial({ color: type.color, metalness: 0.5, roughness: 0.5 })
                        );
                        viperHead.position.y = type.size * 1.2;
                        enemyGroup.add(viperHead);
                        
                        // Glowing eyes
                        eyeLeft = new THREE.Mesh(
                            new THREE.SphereGeometry(0.08, 8, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: 0x00ff00,
                                emissive: 0x00ff00,
                                emissiveIntensity: 2
                            })
                        );
                        eyeLeft.position.set(-0.1, type.size * 1.3, type.size * 0.15);
                        enemyGroup.add(eyeLeft);
                        
                        eyeRight = eyeLeft.clone();
                        eyeRight.position.x = 0.1;
                        enemyGroup.add(eyeRight);
                        
                        // Fangs
                        for (let side = -1; side <= 1; side += 2) {
                            const fang = new THREE.Mesh(
                                new THREE.ConeGeometry(0.05, 0.25, 8),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xffffff,
                                    metalness: 0.9,
                                    roughness: 0.1
                                })
                            );
                            fang.position.set(side * 0.08, type.size * 1.1, type.size * 0.2);
                            enemyGroup.add(fang);
                        }
                        break;
                        
                    default:
                        mainMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(type.size, type.size, type.size),
                            new THREE.MeshStandardMaterial({ color: type.color })
                        );
                        enemyGroup.add(mainMesh);
                }
                
                let x, z;
                do {
                    x = (Math.random() - 0.5) * ARENA_SIZE * 1.5;
                    z = (Math.random() - 0.5) * ARENA_SIZE * 1.5;
                } while (
                    Math.sqrt(x*x + z*z) < 15 || 
                    (Math.abs(x - SAFE_ROOM.x) < SAFE_ROOM.width && Math.abs(z - SAFE_ROOM.z) < SAFE_ROOM.depth)
                );
                
                enemyGroup.position.set(x, type.size / 2, z);
                enemyGroup.castShadow = true;
                scene.add(enemyGroup);
                
                // Add point light to enemy
                const enemyLight = new THREE.PointLight(type.color, 0.4, type.size * 4);
                enemyLight.position.copy(enemyGroup.position);
                scene.add(enemyLight);
                
                enemies.push({
                    mesh: enemyGroup,
                    position: enemyGroup.position,
                    health: type.health,
                    maxHealth: type.health,
                    enemyType: type,
                    isBoss: false,
                    light: enemyLight,
                    mainBody: mainMesh,
                    eyeLeft: eyeLeft,
                    eyeRight: eyeRight
                });
            }
        }

        function spawnBoss() {
            const bossType = BOSS_TYPES[Math.floor(Math.random() * BOSS_TYPES.length)];
            const boss = createEnemy(bossType);
            
            // Show boss announcement
            const announcement = document.createElement('div');
            announcement.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 42px;
                font-weight: bold;
                color: #ff4444;
                text-shadow: 0 0 40px rgba(255, 100, 100, 1), 0 0 80px rgba(255, 100, 100, 0.8);
                z-index: 100;
                pointer-events: none;
                animation: bossAnnounce 3s ease-out forwards;
            `;
            announcement.textContent = `‚ö†Ô∏è ${bossType.name} ‚ö†Ô∏è`;
            document.body.appendChild(announcement);
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes bossAnnounce {
                    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                    20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
                    80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            setTimeout(() => announcement.remove(), 3000);
        }

        function updateEnemies() {
            if (gameState.inSafeRoom) return;
            
            // Update boss indicator
            document.getElementById('bossIndicator').style.display = bosses.length > 0 ? 'block' : 'none';
            
            enemies.forEach((enemy, idx) => {
                // Update enemy light position
                if (enemy.light) {
                    enemy.light.position.copy(enemy.position);
                }
                
                // Add pulsing glow effect for visibility
                if (!enemy.isBoss) {
                    const pulse = 0.5 + Math.sin(Date.now() * 0.005 + idx) * 0.3;
                    if (enemy.mainBody && enemy.mainBody.material) {
                        enemy.mainBody.material.emissiveIntensity = enemy.enemyType.glow * pulse;
                    }
                    if (enemy.light) enemy.light.intensity = 0.4 + pulse * 0.3;
                    
                    // Animate eyes
                    if (enemy.eyeLeft && enemy.eyeRight) {
                        const eyePulse = 1.5 + Math.sin(Date.now() * 0.008) * 0.5;
                        enemy.eyeLeft.material.emissiveIntensity = eyePulse;
                        enemy.eyeRight.material.emissiveIntensity = eyePulse;
                    }
                    
                    // Type-specific animations
                    switch(enemy.enemyType.name) {
                        case 'Wasp':
                            // Flap wings
                            const wingFlap = Math.sin(Date.now() * 0.02);
                            enemy.mesh.children.forEach(child => {
                                if (child.geometry && child.geometry.type === 'PlaneGeometry') {
                                    child.rotation.z = child.position.z > 0 ? wingFlap * 0.3 : -wingFlap * 0.3;
                                }
                            });
                            // Bob up and down
                            enemy.position.y = enemy.enemyType.size / 2 + Math.sin(Date.now() * 0.005 + idx) * 0.4;
                            break;
                        case 'Snake':
                            // Slithering motion
                            enemy.mesh.children.forEach((segment, i) => {
                                if (segment.geometry && segment.geometry.type === 'SphereGeometry') {
                                    segment.position.y = Math.sin(Date.now() * 0.005 + i * 0.5) * 0.15;
                                }
                            });
                            break;
                        case 'Scorpion':
                            // Pincers opening/closing
                            let pincerCount = 0;
                            enemy.mesh.children.forEach(child => {
                                if (child.type === 'Group') {
                                    const clawAnim = Math.sin(Date.now() * 0.01) * 0.1;
                                    child.rotation.x = clawAnim;
                                    pincerCount++;
                                }
                            });
                            break;
                        case 'Spider':
                            // Leg wiggle
                            enemy.mesh.children.forEach(child => {
                                if (child.type === 'Group') {
                                    child.rotation.z += 0.01;
                                }
                            });
                            break;
                    }
                }
                
                // Check frozen state
                if (enemy.frozen && Date.now() < enemy.frozenUntil) {
                    // Skip movement for frozen enemies
                    enemy.mesh.rotation.y += 0.01; // Slow rotation when frozen
                    return;
                } else if (enemy.frozen && Date.now() >= enemy.frozenUntil) {
                    // Unfreeze
                    enemy.frozen = false;
                    if (enemy.mainBody && enemy.mainBody.material) {
                        enemy.mainBody.material.emissive = new THREE.Color(enemy.enemyType.color);
                    }
                }
                
                if (enemy.isBoss) {
                    // Boss behavior
                    const boss = enemy;
                    boss.mesh.rotation.y += 0.015;
                    
                    // Pulsing boss glow
                    const bossPulse = 0.8 + Math.sin(Date.now() * 0.003) * 0.3;
                    boss.mesh.children.forEach(child => {
                        if (child.material && child.material.emissive) {
                            child.material.emissiveIntensity = bossPulse;
                        }
                    });
                    if (boss.light) boss.light.intensity = 2 + bossPulse * 1;
                    
                    // Animate energy core
                    if (boss.core) {
                        boss.core.rotation.x += 0.03;
                        boss.core.rotation.y += 0.02;
                        boss.core.material.emissiveIntensity = 1.5 + Math.sin(Date.now() * 0.005) * 0.5;
                    }
                    
                    // Animate eyes
                    if (boss.leftEye && boss.rightEye) {
                        const eyePulse = 2 + Math.sin(Date.now() * 0.007) * 0.5;
                        boss.leftEye.material.emissiveIntensity = eyePulse;
                        boss.rightEye.material.emissiveIntensity = eyePulse;
                    }
                    
                    // Animate aura particles
                    if (boss.auraParticles) {
                        boss.auraParticles.forEach(particle => {
                            particle.userData.angle += particle.userData.speed;
                            const radius = particle.userData.radius + Math.sin(Date.now() * 0.003 + particle.userData.angle) * 0.5;
                            particle.position.x = boss.position.x + Math.cos(particle.userData.angle) * radius;
                            particle.position.z = boss.position.z + Math.sin(particle.userData.angle) * radius;
                            particle.position.y = boss.position.y + particle.userData.height + Math.sin(Date.now() * 0.004 + particle.userData.angle) * 0.3;
                            
                            // Pulse opacity
                            particle.material.opacity = 0.6 + Math.sin(Date.now() * 0.005 + particle.userData.angle) * 0.3;
                        });
                    }
                    
                    // Update boss health bar
                    const healthPercent = (boss.health / boss.maxHealth) * 100;
                    boss.healthBarFill.style.width = healthPercent + '%';
                    
                    // Boss attack patterns
                    if (boss.enemyType.attackPattern === 'charge') {
                        const dir = new THREE.Vector3().subVectors(camera.position, boss.position).normalize();
                        boss.position.addScaledVector(dir, boss.enemyType.speed * 1.5);
                    } else if (boss.enemyType.attackPattern === 'circle') {
                        boss.attackTimer = (boss.attackTimer || 0) + 0.05;
                        const radius = 20;
                        const targetX = camera.position.x + Math.cos(boss.attackTimer) * radius;
                        const targetZ = camera.position.z + Math.sin(boss.attackTimer) * radius;
                        const dir = new THREE.Vector3(targetX - boss.position.x, 0, targetZ - boss.position.z).normalize();
                        boss.position.addScaledVector(dir, boss.enemyType.speed);
                    } else if (boss.enemyType.attackPattern === 'teleport') {
                        boss.teleportTimer = (boss.teleportTimer || 0) + 1;
                        if (boss.teleportTimer > 180) {
                            // Teleport near player
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 15 + Math.random() * 10;
                            boss.position.x = camera.position.x + Math.cos(angle) * dist;
                            boss.position.z = camera.position.z + Math.sin(angle) * dist;
                            boss.teleportTimer = 0;
                            createExplosion(boss.position);
                        } else {
                            const dir = new THREE.Vector3().subVectors(camera.position, boss.position).normalize();
                            boss.position.addScaledVector(dir, boss.enemyType.speed);
                        }
                    }
                    
                    // Spawn minions
                    if (boss.enemyType.spawnMinions) {
                        boss.minionTimer = (boss.minionTimer || 0) + 1;
                        if (boss.minionTimer > 300) {
                            for (let i = 0; i < 3; i++) {
                                createEnemy();
                            }
                            boss.minionTimer = 0;
                        }
                    }
                    
                    // Boss damage to player
                    if (boss.position.distanceTo(camera.position) < boss.enemyType.size + 2 && !gameState.shieldActive) {
                        gameState.health -= boss.enemyType.damage * 0.016;
                    }
                    
                    // Boss defeated
                    if (boss.health <= 0) {
                        scene.remove(boss.mesh);
                        if (boss.light) scene.remove(boss.light);
                        if (boss.auraParticles) {
                            boss.auraParticles.forEach(p => scene.remove(p));
                        }
                        boss.healthBarElement.remove();
                        enemies.splice(idx, 1);
                        bosses.splice(bosses.indexOf(boss), 1);
                        gameState.score += 1000 * (gameState.doubleScore ? 2 : 1);
                        gameState.health = Math.min(gameState.maxHealth, gameState.health + 50);
                        gameState.ammo = gameState.maxAmmo;
                        gameState.bombs += 2;
                        document.getElementById('bombCount').textContent = gameState.bombs;
                        
                        // Massive boss death explosion
                        for (let i = 0; i < 100; i++) {
                            const size = 0.2 + Math.random() * 0.4;
                            const geometry = new THREE.SphereGeometry(size, 8, 8);
                            const color = new THREE.Color().setHSL(Math.random() * 0.15 + 0.1, 1, 0.6);
                            const material = new THREE.MeshBasicMaterial({ 
                                color: color,
                                transparent: true
                            });
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.position.copy(boss.position);
                            scene.add(mesh);
                            
                            const velocity = new THREE.Vector3(
                                (Math.random() - 0.5) * 0.8, 
                                Math.random() * 0.8, 
                                (Math.random() - 0.5) * 0.8
                            );
                            
                            particles.push({
                                mesh,
                                velocity,
                                life: 120,
                                initialSize: size
                            });
                        }
                        
                        // Victory message
                        const victory = document.createElement('div');
                        victory.style.cssText = `
                            position: fixed;
                            top: 40%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            font-size: 36px;
                            font-weight: bold;
                            color: #44ff44;
                            text-shadow: 0 0 30px rgba(100, 255, 100, 1);
                            z-index: 100;
                            pointer-events: none;
                        `;
                        victory.textContent = 'üéâ BOSS DEFEATED! üéâ';
                        document.body.appendChild(victory);
                        setTimeout(() => victory.remove(), 3000);
                    }
                } else {
                    // Regular enemy behavior
                    // Check if frozen
                    if (enemy.frozen && Date.now() < enemy.frozenUntil) {
                        // Don't move, just pulse cyan
                        if (enemy.mainBody && enemy.mainBody.material) {
                            enemy.mainBody.material.emissiveIntensity = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
                        }
                    } else {
                        // Unfreeze
                        if (enemy.frozen) {
                            enemy.frozen = false;
                            if (enemy.mainBody && enemy.mainBody.material) {
                                enemy.mainBody.material.emissive = new THREE.Color(enemy.enemyType.color);
                                enemy.mainBody.material.emissiveIntensity = enemy.enemyType.glow;
                            }
                        }
                        
                        // Normal movement
                        const dir = new THREE.Vector3().subVectors(camera.position, enemy.position).normalize();
                        enemy.position.addScaledVector(dir, enemy.enemyType.speed);
                        enemy.mesh.rotation.y += 0.04;
                    }
                    
                    if (enemy.position.distanceTo(camera.position) < enemy.enemyType.size + 1 && !gameState.shieldActive && !gameState.ghostMode) {
                        gameState.health -= enemy.enemyType.damage * 0.016;
                        if (enemy.enemyType.kamikaze) {
                            scene.remove(enemy.mesh);
                            if (enemy.light) scene.remove(enemy.light);
                            enemies.splice(idx, 1);
                            createExplosion(enemy.position);
                        }
                    }
                    
                    if (enemy.health <= 0) {
                        scene.remove(enemy.mesh);
                        if (enemy.light) scene.remove(enemy.light);
                        enemies.splice(idx, 1);
                        gameState.score += 10 * (gameState.doubleScore ? 2 : 1);
                        createExplosion(enemy.position);
                        const dropChance = gameState.luckyMode ? 0.6 : 0.3;
                        if (Math.random() < dropChance) createPowerup(enemy.position);
                    }
                }
            });
            
            // Spawn regular enemies
            const maxEnemies = bosses.length > 0 ? 5 : (3 + gameState.level);
            while (enemies.length < maxEnemies && bosses.length === 0) createEnemy();
        }

        // ===== POWERUPS =====
        const powerups = [];
        const POWERUP_TYPES = [
            { name: 'üåø Health Boost', effect: () => { gameState.health = Math.min(gameState.maxHealth, gameState.health + 30); } },
            { name: 'üéØ Ammo Pack', effect: () => { gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 20); } },
            { name: 'üí£ Extra Bomb', effect: () => { gameState.bombs += 1; } },
            { name: '‚ö° Speed Boost', duration: 8000, effect: () => { gameState.speedMultiplier = 1.8; }, end: () => { gameState.speedMultiplier = 1; } },
            { name: 'üõ°Ô∏è Shield', duration: 10000, effect: () => { gameState.shieldActive = true; }, end: () => { gameState.shieldActive = false; } },
            { name: 'üåü God Beam', duration: 6000, effect: () => { gameState.godBeamActive = true; }, end: () => { gameState.godBeamActive = false; } },
            { name: 'ü¶ç Titan Mode', duration: 12000, effect: () => { gameState.titanMode = true; camera.position.y = 3; }, end: () => { gameState.titanMode = false; camera.position.y = 1.6; } },
            { name: 'üíö Regeneration', duration: 15000, effect: () => { gameState.regenerating = true; }, end: () => { gameState.regenerating = false; } },
            { name: 'üî• Fire Rate Up', duration: 10000, effect: () => { gameState.fireRateBoost = true; }, end: () => { gameState.fireRateBoost = false; } },
            { name: 'üíÄ Lifesteal', duration: 12000, effect: () => { gameState.lifesteal = true; }, end: () => { gameState.lifesteal = false; } },
            { name: 'üí• Explosive Rounds', duration: 8000, effect: () => { gameState.explosiveRounds = true; }, end: () => { gameState.explosiveRounds = false; } },
            { name: 'üé™ Double Score', duration: 15000, effect: () => { gameState.doubleScore = true; }, end: () => { gameState.doubleScore = false; } },
            { name: 'üåä Freeze Wave', effect: () => { freezeAllEnemies(); } },
            { name: '‚öîÔ∏è Damage Boost', duration: 10000, effect: () => { gameState.damageMultiplier = 2; }, end: () => { gameState.damageMultiplier = 1; } },
            { name: 'üëª Ghost Mode', duration: 8000, effect: () => { gameState.ghostMode = true; }, end: () => { gameState.ghostMode = false; } },
            { name: 'üîÆ Max Health Up', effect: () => { gameState.maxHealth += 20; gameState.health = gameState.maxHealth; } },
            { name: 'üì¶ Max Ammo Up', effect: () => { gameState.maxAmmo += 30; gameState.ammo = gameState.maxAmmo; } },
            { name: 'üå™Ô∏è Whirlwind', effect: () => { createWhirlwind(); } },
            { name: '‚≠ê Lucky Star', duration: 20000, effect: () => { gameState.luckyMode = true; }, end: () => { gameState.luckyMode = false; } },
            { name: 'üé≤ Random Familiar', effect: () => { spawnRandomFamiliar(); } }
        ];

        function freezeAllEnemies() {
            enemies.forEach(enemy => {
                if (!enemy.isBoss) {
                    enemy.frozen = true;
                    enemy.frozenUntil = Date.now() + 5000;
                    if (enemy.mesh.material) {
                        enemy.mesh.children.forEach(child => {
                            if (child.material) {
                                child.material.emissive = new THREE.Color(0x00ffff);
                                child.material.emissiveIntensity = 0.8;
                            }
                        });
                    }
                }
            });
        }

        function createWhirlwind() {
            const whirlwindParticles = [];
            const center = camera.position.clone();
            
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                const radius = 3 + Math.random() * 5;
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x88ff88,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                particle.position.set(
                    center.x + Math.cos(angle) * radius,
                    center.y + Math.random() * 4,
                    center.z + Math.sin(angle) * radius
                );
                scene.add(particle);
                whirlwindParticles.push({ mesh: particle, angle, radius, life: 60 });
            }
            
            const whirlwindInterval = setInterval(() => {
                whirlwindParticles.forEach((p, idx) => {
                    p.angle += 0.2;
                    p.radius *= 1.05;
                    p.mesh.position.x = center.x + Math.cos(p.angle) * p.radius;
                    p.mesh.position.z = center.z + Math.sin(p.angle) * p.radius;
                    p.mesh.position.y += 0.1;
                    p.life--;
                    p.mesh.material.opacity = p.life / 60;
                    
                    // Damage nearby enemies
                    enemies.forEach(enemy => {
                        if (p.mesh.position.distanceTo(enemy.position) < 2) {
                            enemy.health -= 0.5;
                        }
                    });
                    
                    if (p.life <= 0) {
                        scene.remove(p.mesh);
                        whirlwindParticles.splice(idx, 1);
                    }
                });
                
                if (whirlwindParticles.length === 0) {
                    clearInterval(whirlwindInterval);
                }
            }, 16);
        }

        // ===== FAMILIAR SYSTEM =====
        const familiars = [];
        const FAMILIAR_TYPES = [
            { 
                name: 'üêâ Dragon', 
                color: 0xff4444, 
                size: 1.2, 
                ability: 'shoots fire at enemies',
                attackCooldown: 2000,
                damage: 15
            },
            { 
                name: 'ü¶Ö Eagle', 
                color: 0xffaa44, 
                size: 0.8, 
                ability: 'spots distant enemies',
                attackCooldown: 1500,
                damage: 8
            },
            { 
                name: 'üê∫ Wolf', 
                color: 0x8888ff, 
                size: 1, 
                ability: 'attacks nearby enemies',
                attackCooldown: 1000,
                damage: 12
            },
            { 
                name: 'ü¶â Owl', 
                color: 0xbb88ff, 
                size: 0.7, 
                ability: 'reveals powerups',
                attackCooldown: 3000,
                damage: 5
            },
            { 
                name: 'üêØ Tiger', 
                color: 0xff8844, 
                size: 1.3, 
                ability: 'increases damage',
                attackCooldown: 1200,
                damage: 18
            },
            { 
                name: 'ü¶ä Fox', 
                color: 0xff6644, 
                size: 0.9, 
                ability: 'increases speed',
                attackCooldown: 2500,
                damage: 10
            }
        ];

        function spawnRandomFamiliar() {
            if (familiars.length >= 3) {
                // Max 3 familiars
                return;
            }
            
            const type = FAMILIAR_TYPES[Math.floor(Math.random() * FAMILIAR_TYPES.length)];
            const familiarGroup = new THREE.Group();
            
            // Main body
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(type.size * 0.4, 16, 16),
                new THREE.MeshStandardMaterial({
                    color: type.color,
                    emissive: type.color,
                    emissiveIntensity: 0.6,
                    metalness: 0.4,
                    roughness: 0.6
                })
            );
            familiarGroup.add(body);
            
            // Wings/details
            for (let side = -1; side <= 1; side += 2) {
                const wing = new THREE.Mesh(
                    new THREE.BoxGeometry(type.size * 0.6, 0.1, type.size * 0.4),
                    new THREE.MeshStandardMaterial({
                        color: type.color,
                        emissive: type.color,
                        emissiveIntensity: 0.5,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                wing.position.set(side * type.size * 0.4, 0, 0);
                wing.rotation.z = side * Math.PI / 6;
                familiarGroup.add(wing);
            }
            
            // Eyes
            for (let side = -1; side <= 1; side += 2) {
                const eye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 8, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        emissive: 0xffff00,
                        emissiveIntensity: 1.5
                    })
                );
                eye.position.set(side * 0.15, 0.1, type.size * 0.35);
                familiarGroup.add(eye);
            }
            
            // Position behind player
            familiarGroup.position.copy(camera.position);
            familiarGroup.position.y = camera.position.y + 1;
            familiarGroup.castShadow = true;
            scene.add(familiarGroup);
            
            // Light
            const light = new THREE.PointLight(type.color, 0.8, 5);
            light.position.copy(familiarGroup.position);
            scene.add(light);
            
            familiars.push({
                mesh: familiarGroup,
                type: type,
                light: light,
                lastAttack: 0,
                orbitAngle: familiars.length * (Math.PI * 2 / 3),
                targetPos: new THREE.Vector3()
            });
            
            // Show notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 45%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(30, 60, 30, 0.95), rgba(40, 80, 40, 0.9));
                padding: 20px 30px;
                border-radius: 15px;
                font-size: 18px;
                font-weight: bold;
                color: #dcf0dc;
                z-index: 100;
                pointer-events: none;
                border: 2px solid rgba(140, 220, 100, 0.6);
                box-shadow: 0 0 30px rgba(100, 200, 100, 0.5);
            `;
            notification.textContent = `${type.name} has joined you!`;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 2500);
        }

        function updateFamiliars() {
            familiars.forEach((familiar, idx) => {
                // Orbit around player
                familiar.orbitAngle += 0.02;
                const orbitRadius = 3;
                familiar.targetPos.set(
                    camera.position.x + Math.cos(familiar.orbitAngle) * orbitRadius,
                    camera.position.y + 1 + Math.sin(Date.now() * 0.002 + idx) * 0.3,
                    camera.position.z + Math.sin(familiar.orbitAngle) * orbitRadius
                );
                
                // Smooth follow
                familiar.mesh.position.lerp(familiar.targetPos, 0.1);
                familiar.mesh.rotation.y += 0.05;
                
                // Update light
                familiar.light.position.copy(familiar.mesh.position);
                
                // Animate wings
                familiar.mesh.children.forEach((child, i) => {
                    if (i > 0 && i < 3) { // Wings
                        child.rotation.z = Math.sin(Date.now() * 0.01 + idx) * 0.3 * (i === 1 ? -1 : 1);
                    }
                });
                
                // Attack nearest enemy
                if (Date.now() - familiar.lastAttack > familiar.type.attackCooldown) {
                    let nearestEnemy = null;
                    let nearestDist = Infinity;
                    
                    enemies.forEach(enemy => {
                        const dist = familiar.mesh.position.distanceTo(enemy.position);
                        if (dist < nearestDist && dist < 20) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    });
                    
                    if (nearestEnemy) {
                        familiar.lastAttack = Date.now();
                        
                        // Create projectile from familiar to enemy
                        const projectile = new THREE.Mesh(
                            new THREE.SphereGeometry(0.15, 8, 8),
                            new THREE.MeshBasicMaterial({ 
                                color: familiar.type.color,
                                transparent: true,
                                opacity: 0.9
                            })
                        );
                        projectile.position.copy(familiar.mesh.position);
                        scene.add(projectile);
                        
                        const direction = new THREE.Vector3()
                            .subVectors(nearestEnemy.position, familiar.mesh.position)
                            .normalize();
                        
                        const familiarProjectile = {
                            mesh: projectile,
                            direction: direction,
                            speed: 0.5,
                            damage: familiar.type.damage,
                            life: 60
                        };
                        
                        // Update familiar projectiles
                        const updateInterval = setInterval(() => {
                            familiarProjectile.mesh.position.addScaledVector(familiarProjectile.direction, familiarProjectile.speed);
                            familiarProjectile.life--;
                            
                            // Check collision with enemies
                            enemies.forEach(enemy => {
                                if (familiarProjectile.mesh.position.distanceTo(enemy.position) < 2) {
                                    enemy.health -= familiarProjectile.damage * (gameState.damageMultiplier || 1);
                                    scene.remove(familiarProjectile.mesh);
                                    clearInterval(updateInterval);
                                }
                            });
                            
                            if (familiarProjectile.life <= 0) {
                                scene.remove(familiarProjectile.mesh);
                                clearInterval(updateInterval);
                            }
                        }, 16);
                    }
                }
            });
        }

        function createPowerup(position) {
            const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
            
            const geometry = new THREE.IcosahedronGeometry(0.5, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xdcb864,
                emissive: 0xdcb864,
                emissiveIntensity: 0.9,
                metalness: 0.8,
                roughness: 0.2
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.position.y = 0.5;
            mesh.castShadow = true;
            scene.add(mesh);
            
            // Add point light to powerup
            const powerupLight = new THREE.PointLight(0xdcb864, 0.7, 10);
            powerupLight.position.copy(mesh.position);
            scene.add(powerupLight);
            
            // Add outer glow ring
            const ringGeometry = new THREE.TorusGeometry(0.7, 0.12, 8, 16);
            const ringMaterial = new THREE.MeshStandardMaterial({
                color: 0xdcb864,
                emissive: 0xdcb864,
                emissiveIntensity: 1.3,
                transparent: true,
                opacity: 0.6,
                metalness: 0.9,
                roughness: 0.1
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.copy(mesh.position);
            ring.rotation.x = Math.PI / 2;
            scene.add(ring);
            
            // Add orbiting particles
            const orbitParticles = [];
            for (let i = 0; i < 6; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({
                        color: 0xdcb864,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                particle.position.copy(mesh.position);
                scene.add(particle);
                orbitParticles.push(particle);
            }
            
            powerups.push({ mesh, type, spawnTime: Date.now(), light: powerupLight, ring, orbitParticles });
        }

        function updatePowerups() {
            powerups.forEach((p, idx) => {
                p.mesh.rotation.y += 0.06;
                p.mesh.rotation.x += 0.04;
                const bobHeight = 0.5 + Math.sin(Date.now() * 0.003 + idx) * 0.4;
                p.mesh.position.y = bobHeight;
                
                // Animate ring
                p.ring.rotation.z += 0.03;
                p.ring.position.copy(p.mesh.position);
                const ringScale = 1 + Math.sin(Date.now() * 0.005 + idx) * 0.2;
                p.ring.scale.set(ringScale, ringScale, 1);
                
                // Update light with pulsing
                p.light.position.copy(p.mesh.position);
                p.light.intensity = 0.7 + Math.sin(Date.now() * 0.006 + idx) * 0.5;
                
                // Animate orbiting particles
                if (p.orbitParticles) {
                    p.orbitParticles.forEach((particle, i) => {
                        const angle = (Date.now() * 0.003 + i * Math.PI / 3) % (Math.PI * 2);
                        const radius = 0.8 + Math.sin(Date.now() * 0.004) * 0.2;
                        particle.position.x = p.mesh.position.x + Math.cos(angle) * radius;
                        particle.position.z = p.mesh.position.z + Math.sin(angle) * radius;
                        particle.position.y = p.mesh.position.y + Math.sin(angle * 2) * 0.3;
                        particle.material.opacity = 0.5 + Math.sin(Date.now() * 0.005 + i) * 0.3;
                    });
                }
                
                if (p.mesh.position.distanceTo(camera.position) < 2.5) {
                    p.type.effect();
                    if (p.type.duration) {
                        const endTime = Date.now() + p.type.duration;
                        gameState.activePowerups.push({ ...p.type, endTime });
                    }
                    scene.remove(p.mesh);
                    scene.remove(p.ring);
                    scene.remove(p.light);
                    if (p.orbitParticles) {
                        p.orbitParticles.forEach(particle => scene.remove(particle));
                    }
                    powerups.splice(idx, 1);
                    
                    // Enhanced pickup particle effect
                    for (let i = 0; i < 25; i++) {
                        const particle = new THREE.Mesh(
                            new THREE.SphereGeometry(0.12, 8, 8),
                            new THREE.MeshBasicMaterial({ 
                                color: 0xdcb864,
                                transparent: true
                            })
                        );
                        particle.position.copy(p.mesh.position);
                        scene.add(particle);
                        particles.push({
                            mesh: particle,
                            velocity: new THREE.Vector3(
                                (Math.random() - 0.5) * 0.3, 
                                Math.random() * 0.5, 
                                (Math.random() - 0.5) * 0.3
                            ),
                            life: 50
                        });
                    }
                }
                
                if (Date.now() - p.spawnTime > 20000) {
                    scene.remove(p.mesh);
                    scene.remove(p.ring);
                    scene.remove(p.light);
                    if (p.orbitParticles) {
                        p.orbitParticles.forEach(particle => scene.remove(particle));
                    }
                    powerups.splice(idx, 1);
                }
            });
            
            gameState.activePowerups = gameState.activePowerups.filter(p => {
                if (Date.now() > p.endTime) {
                    if (p.end) p.end();
                    return false;
                }
                return true;
            });
        }

        // ===== PROJECTILES =====
        const projectiles = [];
        function createProjectile() {
            if (gameState.ammo <= 0) {
                return;
            }
            gameState.ammo--;
            
            const geometry = new THREE.SphereGeometry(0.2, 12, 12);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffee88,
                emissive: 0xffdd44,
                emissiveIntensity: 1.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(camera.position);
            
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            scene.add(mesh);
            
            // Add projectile light
            const projectileLight = new THREE.PointLight(0xffee88, 0.8, 5);
            projectileLight.position.copy(mesh.position);
            scene.add(projectileLight);
            
            projectiles.push({ 
                mesh, 
                direction, 
                spawnTime: Date.now(),
                light: projectileLight,
                trail: []
            });
        }

        function updateProjectiles() {
            projectiles.forEach((proj, idx) => {
                proj.mesh.position.addScaledVector(proj.direction, 0.8);
                proj.light.position.copy(proj.mesh.position);
                
                // Create trail effect
                if (Math.random() > 0.7) {
                    const trailParticle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 6, 6),
                        new THREE.MeshBasicMaterial({ 
                            color: 0xffdd44,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    trailParticle.position.copy(proj.mesh.position);
                    scene.add(trailParticle);
                    particles.push({
                        mesh: trailParticle,
                        velocity: new THREE.Vector3(0, 0, 0),
                        life: 15
                    });
                }
                
                enemies.forEach(enemy => {
                    const hitRange = enemy.isBoss ? enemy.enemyType.size : enemy.enemyType.size * 0.8;
                    if (proj.mesh.position.distanceTo(enemy.position) < hitRange) {
                        const baseDamage = gameState.godBeamActive ? 100 : (enemy.isBoss ? 3 : 5);
                        const damage = baseDamage * gameState.damageMultiplier;
                        enemy.health -= damage;
                        
                        // Lifesteal
                        if (gameState.lifesteal && !enemy.isBoss) {
                            gameState.health = Math.min(gameState.maxHealth, gameState.health + damage * 0.2);
                        }
                        
                        // Explosive rounds
                        if (gameState.explosiveRounds) {
                            createExplosion(proj.mesh.position);
                            // Damage nearby enemies
                            enemies.forEach(nearEnemy => {
                                if (nearEnemy !== enemy && proj.mesh.position.distanceTo(nearEnemy.position) < 5) {
                                    nearEnemy.health -= damage * 0.5;
                                }
                            });
                        }
                        
                        scene.remove(proj.mesh);
                        scene.remove(proj.light);
                        projectiles.splice(idx, 1);
                        
                        // Visual hit effect
                        const particleCount = gameState.explosiveRounds ? 16 : 8;
                        for (let i = 0; i < particleCount; i++) {
                            const hitParticle = new THREE.Mesh(
                                new THREE.SphereGeometry(0.15, 6, 6),
                                new THREE.MeshBasicMaterial({ 
                                    color: gameState.explosiveRounds ? 0xff8844 : 0xffff88 
                                })
                            );
                            hitParticle.position.copy(proj.mesh.position);
                            scene.add(hitParticle);
                            particles.push({
                                mesh: hitParticle,
                                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.3, Math.random() * 0.3, (Math.random() - 0.5) * 0.3),
                                life: 30
                            });
                        }
                    }
                });
                
                if (Date.now() - proj.spawnTime > 3000 || 
                    Math.abs(proj.mesh.position.x) > ARENA_SIZE || 
                    Math.abs(proj.mesh.position.z) > ARENA_SIZE) {
                    scene.remove(proj.mesh);
                    scene.remove(proj.light);
                    projectiles.splice(idx, 1);
                }
            });
        }

        // ===== PARTICLES =====
        const particles = [];
        function createExplosion(position) {
            for (let i = 0; i < 30; i++) {
                const size = 0.1 + Math.random() * 0.2;
                const geometry = new THREE.SphereGeometry(size, 6, 6);
                const color = new THREE.Color().setHSL(Math.random() * 0.1 + 0.1, 0.8, 0.6);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                scene.add(mesh);
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.4, 
                    Math.random() * 0.5, 
                    (Math.random() - 0.5) * 0.4
                );
                
                particles.push({
                    mesh,
                    velocity,
                    life: 60,
                    initialSize: size
                });
            }
            
            // Add flash light
            const flashLight = new THREE.PointLight(0xff8844, 3, 10);
            flashLight.position.copy(position);
            scene.add(flashLight);
            setTimeout(() => scene.remove(flashLight), 100);
        }

        function updateParticles() {
            particles.forEach((p, idx) => {
                p.mesh.position.add(p.velocity);
                p.velocity.y -= 0.015;
                p.velocity.multiplyScalar(0.98);
                p.life--;
                
                const lifePercent = p.life / 60;
                p.mesh.material.opacity = lifePercent;
                p.mesh.scale.set(lifePercent, lifePercent, lifePercent);
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(idx, 1);
                }
            });
        }

        // ===== BOMBS =====
        const bombs = [];
        function dropBomb() {
            if (gameState.bombs <= 0) return;
            gameState.bombs--;
            document.getElementById('bombCount').textContent = gameState.bombs;
            
            const geometry = new THREE.SphereGeometry(0.6, 16, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xb488c8,
                emissive: 0xb488c8,
                emissiveIntensity: 0.9,
                metalness: 0.6,
                roughness: 0.4
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(camera.position);
            scene.add(mesh);
            
            // Add bomb light
            const bombLight = new THREE.PointLight(0xb488c8, 1, 8);
            bombLight.position.copy(mesh.position);
            scene.add(bombLight);
            
            bombs.push({ mesh, timer: 90, light: bombLight });
        }

        function updateBombs() {
            bombs.forEach((bomb, idx) => {
                bomb.timer--;
                const pulseSpeed = Math.max(0.1, bomb.timer / 90);
                bomb.mesh.scale.set(
                    1 + Math.sin(bomb.timer * (1 / pulseSpeed)) * 0.2, 
                    1 + Math.sin(bomb.timer * (1 / pulseSpeed)) * 0.2, 
                    1 + Math.sin(bomb.timer * (1 / pulseSpeed)) * 0.2
                );
                bomb.mesh.rotation.y += 0.1;
                bomb.light.position.copy(bomb.mesh.position);
                bomb.light.intensity = 1 + Math.sin(bomb.timer * 0.1) * 0.5;
                
                if (bomb.timer <= 0) {
                    enemies.forEach(enemy => {
                        if (bomb.mesh.position.distanceTo(enemy.position) < 15) {
                            if (enemy.isBoss) {
                                enemy.health -= 150;
                            } else {
                                enemy.health = 0;
                            }
                        }
                    });
                    createExplosion(bomb.mesh.position);
                    
                    // Create massive explosion effect
                    for (let i = 0; i < 60; i++) {
                        const size = 0.2 + Math.random() * 0.3;
                        const geometry = new THREE.SphereGeometry(size, 8, 8);
                        const material = new THREE.MeshBasicMaterial({ 
                            color: new THREE.Color().setHSL(Math.random() * 0.15 + 0.75, 0.9, 0.6),
                            transparent: true
                        });
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.copy(bomb.mesh.position);
                        scene.add(mesh);
                        particles.push({
                            mesh,
                            velocity: new THREE.Vector3((Math.random() - 0.5) * 0.6, Math.random() * 0.7, (Math.random() - 0.5) * 0.6),
                            life: 90,
                            initialSize: size
                        });
                    }
                    
                    // Add bright flash
                    const flashLight = new THREE.PointLight(0xffffff, 5, 25);
                    flashLight.position.copy(bomb.mesh.position);
                    scene.add(flashLight);
                    setTimeout(() => scene.remove(flashLight), 150);
                    
                    scene.remove(bomb.mesh);
                    scene.remove(bomb.light);
                    bombs.splice(idx, 1);
                }
            });
        }

        // ===== TRAPS =====
        const traps = [];
        function createTrap() {
            const geometry = new THREE.CylinderGeometry(1.8, 1.8, 0.15, 20);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x8a4a4a,
                emissive: 0x6a2a2a,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.8,
                metalness: 0.4,
                roughness: 0.6
            });
            const mesh = new THREE.Mesh(geometry, material);
            let x, z;
            do {
                x = (Math.random() - 0.5) * ARENA_SIZE * 1.5;
                z = (Math.random() - 0.5) * ARENA_SIZE * 1.5;
            } while (Math.abs(x - SAFE_ROOM.x) < SAFE_ROOM.width && Math.abs(z - SAFE_ROOM.z) < SAFE_ROOM.depth);
            mesh.position.set(x, 0.08, z);
            mesh.receiveShadow = true;
            scene.add(mesh);
            
            // Add warning light
            const trapLight = new THREE.PointLight(0xff4444, 0.5, 5);
            trapLight.position.set(x, 0.5, z);
            scene.add(trapLight);
            
            // Add spikes geometry
            const spikeGroup = new THREE.Group();
            for (let i = 0; i < 8; i++) {
                const spike = new THREE.Mesh(
                    new THREE.ConeGeometry(0.1, 0.4, 6),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x6a3a3a,
                        metalness: 0.7,
                        roughness: 0.3
                    })
                );
                const angle = (i / 8) * Math.PI * 2;
                spike.position.set(Math.cos(angle) * 1.2, -0.15, Math.sin(angle) * 1.2);
                spike.rotation.z = Math.PI;
                spikeGroup.add(spike);
            }
            spikeGroup.position.copy(mesh.position);
            scene.add(spikeGroup);
            
            traps.push({ mesh, triggered: false, light: trapLight, spikes: spikeGroup });
        }

        function updateTraps() {
            traps.forEach((trap, idx) => {
                // Pulse warning light
                trap.light.intensity = 0.5 + Math.sin(Date.now() * 0.005) * 0.3;
                trap.mesh.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.004) * 0.2;
                
                if (!trap.triggered && trap.mesh.position.distanceTo(camera.position) < 2.5 && !gameState.shieldActive) {
                    trap.triggered = true;
                    gameState.health -= 25;
                    trap.mesh.material.emissiveIntensity = 1.5;
                    trap.light.intensity = 3;
                    
                    // Animate spikes up
                    trap.spikes.children.forEach(spike => {
                        spike.position.y = 0.3;
                    });
                    
                    // Damage particles
                    for (let i = 0; i < 20; i++) {
                        const particle = new THREE.Mesh(
                            new THREE.SphereGeometry(0.1, 6, 6),
                            new THREE.MeshBasicMaterial({ color: 0xff4444 })
                        );
                        particle.position.copy(trap.mesh.position);
                        scene.add(particle);
                        particles.push({
                            mesh: particle,
                            velocity: new THREE.Vector3((Math.random() - 0.5) * 0.3, Math.random() * 0.4, (Math.random() - 0.5) * 0.3),
                            life: 40
                        });
                    }
                    
                    setTimeout(() => {
                        scene.remove(trap.mesh);
                        scene.remove(trap.light);
                        scene.remove(trap.spikes);
                        traps.splice(idx, 1);
                    }, 800);
                }
            });
        }

        // ===== SAFE ROOM =====
        function updateSafeRoomStatus() {
            const inRoom = 
                Math.abs(camera.position.x - SAFE_ROOM.x) < SAFE_ROOM.width / 2 &&
                Math.abs(camera.position.z - SAFE_ROOM.z) < SAFE_ROOM.depth / 2;
            
            gameState.inSafeRoom = inRoom;
            document.getElementById('safeRoomStatus').style.display = inRoom ? 'block' : 'none';
            document.getElementById('answerInSafeRoom').style.display = inRoom ? 'block' : 'none';
        }

        // ===== QUESTION SYSTEM =====
        let currentQuestion = null;
        let answeredInSafeRoom = false;

        function showQuestion(fromSafeRoom) {
            answeredInSafeRoom = fromSafeRoom;
            gameState.paused = true;
            currentQuestion = questions[Math.floor(Math.random() * questions.length)];
            
            document.getElementById('questionText').textContent = currentQuestion.question;
            const buttonsContainer = document.getElementById('answerButtons');
            buttonsContainer.innerHTML = '';
            
            currentQuestion.answers.forEach((answer, idx) => {
                const btn = document.createElement('button');
                btn.className = 'answer-btn';
                btn.textContent = answer;
                btn.onclick = () => checkAnswer(idx, btn);
                buttonsContainer.appendChild(btn);
            });
            
            document.getElementById('questionModal').style.display = 'flex';
        }

        function checkAnswer(selectedIdx, btn) {
            const correct = selectedIdx === currentQuestion.correct;
            const allBtns = document.querySelectorAll('.answer-btn');
            
            allBtns.forEach((b, idx) => {
                b.disabled = true;
                if (idx === currentQuestion.correct) {
                    b.classList.add('correct');
                } else if (b === btn && !correct) {
                    b.classList.add('wrong');
                }
            });
            
            setTimeout(() => {
                if (correct) {
                    gameState.correct++;
                    gameState.streak++;
                    const bonus = answeredInSafeRoom ? 150 : 100;
                    gameState.score += bonus + (gameState.streak * 10);
                    gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 10);
                    gameState.health = Math.min(gameState.maxHealth, gameState.health + (answeredInSafeRoom ? 20 : 10));
                    if (answeredInSafeRoom) gameState.bombs = Math.min(5, gameState.bombs + 1);
                } else {
                    gameState.wrong++;
                    gameState.streak = 0;
                }
                
                document.getElementById('questionModal').style.display = 'none';
                gameState.paused = false;
                answeredInSafeRoom = false;
                
                if (enemies.length < 8) createEnemy();
            }, 1500);
        }

        // ===== PC CONTROLS =====
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            arrowup: false,
            arrowleft: false,
            arrowdown: false,
            arrowright: false,
            space: false,
            b: false,
            q: false
        };

        const mouse = {
            locked: false,
            yaw: 0,    // Horizontal rotation
            pitch: 0,  // Vertical rotation
            sensitivity: 0.003
        };

        let shootInterval = null;
        let isGameStarted = false;

        // Start game on button click
        document.getElementById('startGame').addEventListener('click', () => {
            document.getElementById('controlsOverlay').style.display = 'none';
            document.getElementById('gameContainer').requestPointerLock();
            isGameStarted = true;
        });

        // Pointer lock
        document.addEventListener('pointerlockchange', () => {
            mouse.locked = document.pointerLockElement === document.getElementById('gameContainer');
            if (!mouse.locked && isGameStarted && !gameState.gameOver) {
                // Show instructions to click to continue
                if (!document.getElementById('pauseOverlay')) {
                    const overlay = document.createElement('div');
                    overlay.id = 'pauseOverlay';
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(10, 25, 10, 0.95);
                        z-index: 150;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        cursor: pointer;
                        backdrop-filter: blur(5px);
                    `;
                    overlay.innerHTML = `
                        <div style="text-align: center; color: #dcf0dc; font-size: 24px;">
                            <div style="margin-bottom: 20px;">‚è∏Ô∏è PAUSED</div>
                            <div style="font-size: 16px;">Click to continue playing</div>
                            <div style="font-size: 14px; margin-top: 10px; color: #a0d0a0;">Press ESC to exit pointer lock</div>
                        </div>
                    `;
                    overlay.addEventListener('click', () => {
                        document.getElementById('gameContainer').requestPointerLock();
                    });
                    document.body.appendChild(overlay);
                }
            } else {
                const overlay = document.getElementById('pauseOverlay');
                if (overlay) overlay.remove();
            }
        });

        // Request pointer lock on any click in game container
        document.getElementById('gameContainer').addEventListener('click', () => {
            if (!mouse.locked && isGameStarted) {
                document.getElementById('gameContainer').requestPointerLock();
            }
        });

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
                e.preventDefault();
            }

            // Shoot on space
            if (key === ' ' && !shootInterval && mouse.locked) {
                keys.space = true;
                createProjectile();
                shootInterval = setInterval(() => {
                    if (keys.space) createProjectile();
                }, gameState.godBeamActive ? 20 : (gameState.fireRateBoost ? 60 : 120));
                e.preventDefault();
            }

            // Drop bomb on B
            if (key === 'b' && mouse.locked) {
                dropBomb();
                e.preventDefault();
            }

            // Answer question on Q
            if (key === 'q' && mouse.locked) {
                if (gameState.inSafeRoom) {
                    showQuestion(true);
                } else {
                    showQuestion(false);
                }
                e.preventDefault();
            }

            // Escape to unlock pointer
            if (e.key === 'Escape') {
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }

            if (key === ' ') {
                keys.space = false;
                if (shootInterval) {
                    clearInterval(shootInterval);
                    shootInterval = null;
                }
            }
        });

        // Mouse movement
        document.addEventListener('mousemove', (e) => {
            if (mouse.locked) {
                // Update yaw (horizontal) and pitch (vertical)
                mouse.yaw -= e.movementX * mouse.sensitivity;
                mouse.pitch -= e.movementY * mouse.sensitivity;
                
                // Clamp pitch to prevent looking too far up or down
                const maxPitch = Math.PI / 2.5;
                mouse.pitch = Math.max(-maxPitch, Math.min(maxPitch, mouse.pitch));
            }
        });

        // Mouse click to shoot
        document.addEventListener('mousedown', (e) => {
            if (e.button === 0 && mouse.locked && !gameState.paused) { // Left click
                createProjectile();
                shootInterval = setInterval(() => {
                    createProjectile();
                }, gameState.godBeamActive ? 20 : (gameState.fireRateBoost ? 60 : 120));
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) { // Left click
                if (shootInterval) {
                    clearInterval(shootInterval);
                    shootInterval = null;
                }
            }
        });

        // Safe room button click
        document.getElementById('answerInSafeRoom').addEventListener('click', () => {
            if (gameState.inSafeRoom) showQuestion(true);
        });

        // ===== MINIMAP =====
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 90; minimapCanvas.height = 90;

        function updateMinimap() {
            minimapCtx.fillStyle = 'rgba(20, 40, 20, 0.95)';
            minimapCtx.fillRect(0, 0, 90, 90);
            const scale = 90 / (ARENA_SIZE * 2);
            const ox = 45, oy = 45;
            
            // Safe room
            minimapCtx.fillStyle = 'rgba(140, 220, 100, 0.4)';
            minimapCtx.fillRect((SAFE_ROOM.x - SAFE_ROOM.width/2) * scale + ox, (SAFE_ROOM.z - SAFE_ROOM.depth/2) * scale + oy, SAFE_ROOM.width * scale, SAFE_ROOM.depth * scale);
            
            enemies.forEach(e => {
                if (e.isBoss) {
                    // Draw boss as large pulsing circle
                    minimapCtx.fillStyle = '#ff4444';
                    minimapCtx.beginPath();
                    const pulse = 4 + Math.sin(Date.now() * 0.01) * 1;
                    minimapCtx.arc(e.position.x * scale + ox, e.position.z * scale + oy, pulse, 0, Math.PI * 2);
                    minimapCtx.fill();
                    minimapCtx.strokeStyle = '#ff8888';
                    minimapCtx.lineWidth = 2;
                    minimapCtx.stroke();
                } else {
                    minimapCtx.fillStyle = e.enemyType.kamikaze ? '#ff8844' : '#ffaa44';
                    minimapCtx.beginPath();
                    minimapCtx.arc(e.position.x * scale + ox, e.position.z * scale + oy, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            minimapCtx.fillStyle = '#8dc464';
            minimapCtx.beginPath();
            minimapCtx.arc(camera.position.x * scale + ox, camera.position.z * scale + oy, 3, 0, Math.PI * 2);
            minimapCtx.fill();
        }

        // ===== MAIN LOOP =====
        function checkLevelProgress() {
            const newLevel = Math.floor((gameState.correct * 3 + gameState.score / 400) / 10) + 1;
            if (newLevel > gameState.level && newLevel <= 10) {
                gameState.level = newLevel;
                const indicator = document.getElementById('levelIndicator');
                indicator.textContent = `üå¥ LEVEL ${newLevel} üå¥`;
                indicator.classList.add('show');
                setTimeout(() => indicator.classList.remove('show'), 2500);
                generateLevel(newLevel);
                gameState.health = Math.min(gameState.maxHealth, gameState.health + 30);
                gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 20);
                for (let i = 0; i < newLevel; i++) createTrap();
                
                // Spawn boss at levels 3, 6, 9
                if (newLevel % 3 === 0 && bosses.length === 0) {
                    setTimeout(() => {
                        spawnBoss();
                    }, 2000);
                }
            }
        }
        
        let shieldMesh = null;
        function updateShieldVisual() {
            if (gameState.shieldActive && !shieldMesh) {
                shieldMesh = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(2.8, 1), 
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8dc464, 
                        emissive: 0x8dc464,
                        emissiveIntensity: 0.5,
                        transparent: true, 
                        opacity: 0.25, 
                        wireframe: true,
                        metalness: 0.8,
                        roughness: 0.2
                    })
                );
                scene.add(shieldMesh);
                
                // Add shield light
                const shieldLight = new THREE.PointLight(0x8dc464, 0.8, 8);
                shieldMesh.userData.light = shieldLight;
                scene.add(shieldLight);
            }
            if (shieldMesh) {
                if (gameState.shieldActive) {
                    shieldMesh.position.copy(camera.position);
                    shieldMesh.rotation.y += 0.04;
                    shieldMesh.rotation.x += 0.02;
                    
                    // Pulse effect
                    const pulse = 0.25 + Math.sin(Date.now() * 0.005) * 0.1;
                    shieldMesh.material.opacity = pulse;
                    shieldMesh.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.005) * 0.3;
                    
                    if (shieldMesh.userData.light) {
                        shieldMesh.userData.light.position.copy(camera.position);
                        shieldMesh.userData.light.intensity = 0.8 + Math.sin(Date.now() * 0.005) * 0.4;
                    }
                } else {
                    scene.remove(shieldMesh);
                    if (shieldMesh.userData.light) scene.remove(shieldMesh.userData.light);
                    shieldMesh = null;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Apply mouse look rotation FIRST (works even when paused)
            camera.rotation.order = 'YXZ';
            camera.rotation.y = mouse.yaw;
            camera.rotation.x = mouse.pitch;
            
            if (gameState.gameOver) return;
            if (gameState.paused) {
                renderer.render(scene, camera);
                return;
            }

            // Movement - WASD or Arrow keys
            const moveX = (keys.a || keys.arrowleft ? -1 : 0) + (keys.d || keys.arrowright ? 1 : 0);
            const moveZ = (keys.w || keys.arrowup ? -1 : 0) + (keys.s || keys.arrowdown ? 1 : 0);
            
            if (moveX !== 0 || moveZ !== 0) {
                // Create movement vector
                const moveDir = new THREE.Vector3(moveX, 0, moveZ).normalize();
                
                // Rotate movement direction based on camera yaw (horizontal rotation only)
                moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
                
                const speed = (gameState.titanMode ? 0.35 : 0.18) * gameState.speedMultiplier;
                camera.position.addScaledVector(moveDir, speed);
                camera.position.x = Math.max(-ARENA_SIZE + 2, Math.min(ARENA_SIZE - 2, camera.position.x));
                camera.position.z = Math.max(-ARENA_SIZE + 2, Math.min(ARENA_SIZE - 2, camera.position.z));
            }

            updateEnemies();
            updatePowerups();
            updateProjectiles();
            updateParticles();
            updateBombs();
            updateTraps();
            updateShieldVisual();
            updateMinimap();
            updateSafeRoomStatus();
            checkLevelProgress();
            updateDustParticles();
            updateFamiliars();

            // Regeneration effect
            if (gameState.regenerating && gameState.health < gameState.maxHealth) {
                gameState.health = Math.min(gameState.maxHealth, gameState.health + 0.1);
            }

            // Ghost mode - no collision with enemies
            if (gameState.ghostMode) {
                // Handled in enemy collision checks
            }

            // UI
            document.getElementById('health').textContent = Math.ceil(gameState.health);
            document.getElementById('healthBar').style.width = (gameState.health / gameState.maxHealth * 100) + '%';
            document.getElementById('ammo').textContent = gameState.ammo;
            document.getElementById('ammoBar').style.width = (gameState.ammo / gameState.maxAmmo * 100) + '%';
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('streak').textContent = gameState.streak;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('bombCount').textContent = gameState.bombs;
            document.getElementById('enemyCount').textContent = enemies.length;
            document.getElementById('correct').textContent = gameState.correct;
            document.getElementById('wrong').textContent = gameState.wrong;

            document.getElementById('powerupsList').innerHTML = gameState.activePowerups.map(p => {
                const rem = Math.max(0, Math.ceil((p.endTime - Date.now()) / 1000));
                return `<div class="powerup-item">${p.name} (${rem}s)</div>`;
            }).join('');

            if (gameState.health <= 0) {
                gameState.gameOver = true;
                document.getElementById('gameOverText').innerHTML = `
                    <div style="font-size: 26px; margin-bottom: 12px;">üçÇ GAME OVER üçÇ</div>
                    <div>Score: <span style="color: #8dc464;">${gameState.score}</span></div>
                    <div>Level: <span style="color: #8dc464;">${gameState.level}</span></div>
                    <div style="margin-top: 15px; font-size: 14px;">Press F5 to restart</div>
                `;
                document.getElementById('gameMessage').style.display = 'block';
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
            }

            renderer.render(scene, camera);
        }

        generateLevel(1);
        for (let i = 0; i < 4; i++) createEnemy();
        for (let i = 0; i < 2; i++) createTrap();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
